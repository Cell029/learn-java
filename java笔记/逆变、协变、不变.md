
- 协变：子类型关系保持不变（“顺着来”）
- 逆变：子类型关系反过来（“逆着来”）
- 不变：子类型关系不允许传递（“不许动”）

# 1. 逆变与协变

逆变与协变描述的是类型转换后的继承关系。定义 A、B 两个类型，A 是由 B 派生出来的子类，`f()` 表示类型转换如 `new List()`；

```java
class Animal {
    void speak() {
        System.out.println("Animal speaks");
    }
}

class Dog extends Animal {
    void bark() {
        System.out.println("Dog barks");
    }
}

class Cat extends Animal {
    void meow() {
        System.out.println("Cat meows");
    }
}
```

协变只允许读取子类元素，因为不管里面存放的是什么类型，最终都能编译成 Animal 类，但不能添加元素（因为不知道具体的子类型）。编译器不知道 `List<? extends Animal>` 是 `List<Animal>`、`List<Dog>`、`List<Cat>` 中的哪个，只能保证你读出来的是某种 Animal，因此只能读（多态体现在读取对象上），不能写。

```java
// 列表中的元素是 Animal 的子类（包括 Animal 本身）
public static void printAnimals(List<? extends Animal> animals) {
    for (Animal a : animals) {
        a.speak(); // 可以调用 Animal 的方法
    }
    // animals.add(new Dog()); // 不允许添加任何对象
}
```

逆变则允许写入子类实例，写入的类型可以为 Dog 或 Dog 的子类，也可以是 Dog 的父类的其它子类；但读取时只能视为 Object，因为添加的元素可能是多种类型，所以只能以 Objcet 类型来接收。
编译器只知道可以安全地往 `List<? super Dog>` 添加 `Dog` 或 `Dog` 的子类。但不能保证从中取出的元素是 Dog 类型（可能是 Animal 或 Object），所以读取类型必须是 `Object`。

```java
// 列表中的元素是 Dog 的父类（包括 Dog 本身），写入 Dog 或其子类
public static void addDogs(List<? super Dog> list) {
    list.add(new Dog()); // 可以添加 Dog 或 Dog 的子类
    // list.add(new SubDog()); // SubDog 是 Dog 的子类
    // Dog d = list.get(0); // 不能直接取出为 Dog
    Object obj = list.get(0); // 只能当作 Object 使用
}
```

在 `addDogs()` 方法内部只能添加 Dog 或 Dog 的子类，因为并不知道 `list` 的具体类型是 `Object` 还是 `Animal` 还是 `Dog`。但 `List<? super Dog>` 表示可以传入 `List<Dog>`、`List<Animal>`、`List<Object>`。

```java
List<Animal> animals = new ArrayList<>();
addDogs(animals);

List<Object> objects = new ArrayList<>();
addDogs(objects);
```

泛型本身是不具有协变或逆变特性的，也就是说：即使 `Dog` 是 `Animal` 的子类，`ArrayList<Dog>` 也不是 `ArrayList<Animal>` 的子类。泛型在 Java 中是不变的（invariant）。只有使用了上限通配符和下线通配符后才能使用协变与逆变的特性：

```java
List<? extends Animal> list = new ArrayList<Dog>(); // 合法协变
List<? super Dog> list = new ArrayList<Animal>(); // 合法逆变
```

所以：

- 协变：子类型可以替代父类型的位置进行赋值
- 逆变：父类型可以替代子类型的位置进行赋值

例如：

```java
// 利用协变进行只读
public void printAnimalNames(List<? extends Animal> animals) {
    for (Animal animal : animals) {
        System.out.println(animal.getName());
    }
}

printAnimalNames(new ArrayList<Dog>());
printAnimalNames(new ArrayList<Cat>());
```

```java
// 利用逆变只写
public void addDogs(List<? super Dog> list) {
    list.add(new Dog());
    list.add(new SubDog()); // Dog 的子类
}

addDogs(new ArrayList<Dog>());
addDogs(new ArrayList<Animal>());
addDogs(new ArrayList<Object>());
```

****
# 2. 不变

不变即具体类型接收具体类型。

```java
public void process(List<Animal> animals) {
    Animal a = animals.get(0); // 读取
    animals.add(new Dog()); // 写入
}
```

****
# 3. 数组的协变特性

在 Java 中，数组是协变的，如果 `Dog` 是 `Animal` 的子类，那么 `Dog[]` 也是 `Animal[]` 的子类。

```java
Dog[] dogs = new Dog[3];
Animal[] animals = dogs; // 合法，数组是协变的
animals[0] = new Cat(); // 运行时异常：ArrayStoreException
```

但 Java 只是允许把 `Dog[]` 当成 `Animal[]` 来用，它底层实际还是 `Dog[]`，所以一旦塞进 `Cat`，JVM 就会抛出异常。这样设计的目的主要是为了简化对数组的处理，避免进行多次的强制转型。但是这是一种早期不完全类型安全的妥协设计，所以在 Java 推出泛型之后，泛型就默认不再协变了。

****
# 4. 多态与协变的关系

>多态是面向对象的运行时行为，而协变是类型系统的编译时特性，两者都体现了子类可以替代父类的原则，但用在不同层面且目的不同。

多态强调的是方法调用行为的动态绑定：

```java
class Animal {
    void speak() {
        System.out.println("Animal speaks");
    }
}

class Dog extends Animal {
    void speak() {
        System.out.println("Dog barks");
    }
}

Animal a = new Dog(); // 多态
a.speak(); // Dog barks（运行时决定）
```

协变是类型系统中的一种关系，描述的是：是否允许子类型替代父类型。

```java
class Animal {
    Animal getAnimal() { 
	    return new Animal(); 
    }
}
class Dog extends Animal {
    @Override
    Dog getAnimal() {
		return new Dog(); // 返回类型协变
	}  
}
```

```java
class Animal {
    void eat() {
        System.out.println("Animal eats");
    }
}

class Dog extends Animal {
    @Override
    void eat() {
        System.out.println("Dog eats");
    }
}

public void feedAll(Animal[] animals) {
    for (Animal a : animals) {
        a.eat();  // 多态：运行时决定调用 Dog 的 eat()
    }
}

Dog[] dogs = new Dog[3];
feedAll(dogs); // 协变：Dog[] 被当成 Animal[] 传入
```

****




