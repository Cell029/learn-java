
>建立在数组有序的情况下进行查找，每次查找数组的中间元素与待找元素对比，小了找右边，大了找左边

```java
public static int binarySearch(int[] arr, int num) {  
    quickSort(arr, 0, arr.length - 1);  
    System.out.println(Arrays.toString(arr));  
    int begin = 0;  
    int end = arr.length - 1;  
    while (begin <= end) {  
        int mid = (begin + end) / 2;  
        if (arr[mid] == num) {
        // 当begin==end时一定会找到下标，除非要找的元素不在数组中  
            return mid;  
        } else if (arr[mid] < num) {  
            begin = mid + 1;  
        } else if (arr[mid] > num) {  
            end = mid - 1;  
        }  
    }  
    return -1;  
}  
  
public static void quickSort(int[] arr, int left, int right) {  
    if (left >= right) return;  
    int pivot = arr[left];  
    int i = left, j = right;  
    while (i < j) {  
        while (i < j && arr[j] > pivot) {  
            j--;  
        }  
        if (i < j) {  
            arr[i++] = arr[j];  
        }  
        while (i < j && arr[i] < pivot) {  
            i++;  
        }  
        if (i < j) {  
            arr[j--] = arr[i];  
        }  
    }  
    arr[i] = pivot;  
    quickSort(arr, left, i - 1);  
    quickSort(arr, i + 1, right);  
}
```

**递归版折半查找**

```java
public static void main(String[] args) {  
    int[] arr = {78, 56, 1, 90, 45, 98, 52, 14, 2};  
    quickSort(arr, 0, arr.length - 1);  
    System.out.println(Arrays.toString(arr));  
    int target = 90;  
    int index = binarySearch(arr, 0, arr.length - 1, target);  
    System.out.println(target + "的下标为：" + index);  
}  
  
public static int binarySearch(int[] arr, int low, int high, int target) {  
    if (low > high) return -1;  
    int mid = low + (high - low) / 2;  
    if (arr[mid] == target) {  
        return mid;  
    } else if (arr[mid] < target) {  
        return binarySearch(arr, mid + 1, high, target);  
    } else {  
        return binarySearch(arr, low, mid - 1, target);  
    }  
}
```