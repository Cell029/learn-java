
# 一.toString()

>`toString`是属于`Object`类中的方法,因为所有的类默认继承它,所以每个类都默认拥有`toString`并且可以重写它
>
>这个方法的作用是将对象转换成字符串的形式表现

![](images/Object类中的方法/file-20250412171830.png)

>返回格式:对象的全限定名 + @ + 十六进制(哈希码),这个可以看作对象的地址

****

**(1) 当输出对象时会自动调用toString**

![](images/Object类中的方法/file-20250412172554.png)

![](images/Object类中的方法/file-20250412172650.png)

>在`System.out.println();`输出对象的原码中会先对将要输出的对象进行判断是否为空,如果为空就输出`null`,否则调用`toString`

>因此直接输出对象和对象调用`toString`是不一样的,直接调用没有判断是否为空的过程

>因为这个特性,在类中定义一个对象为属性时,在`toString`中输出这个字段的时候也会自动调用`toString`方法,所以如果这个字段中没有重写`toString`就会输出类名@哈希值,这也是为什么建议重写`toString`方法

****

**(2) 设计原理**

>默认的`toString`的输出更像一种身份标识  
>
>`getClass().getName()`用来获取当前对象的名称
>
>`hashCode()`返回的是对象的内存身份标识,它代表的不是真实的内存地址

****

**(3) 方便调式**

>当没有重写`toString`时输出的对象只能知道当前对象是哪个类的,非常不方便,但是在类中重写后就可以非常清楚的看到对象中的每个字段了,可读性大大提升

****

**(4) String重写toString**

![](images/Object类中的方法/file-20250412200218.png)

>因为String本身就是字符串的最终表示,所以可以直接用`this`引用指向内存中的地址,这个地址存的就是字符串(学完数组详细介绍String)

****
# 二.equals

>判断两个对象是否相等

****

**(1) equals的实现**

![](images/Object类中的方法/file-20250412190014.png)

>`equals`方法的本质是`==`的比较,所以两个对象比较的其实是引用的地址,也就是当前对象的引用和传入的引用,如果两个对象的引用指向同一个地址就返回`true`
>
>所以equals通常是要进行重写的,不然这个方法和`==`就没什么区别

****

**(2) String重写equals**

>因为`String`是一个类,所以所有的字符串其实都是一个对象,如果还是使用没有重写的`equals`的话就会出现`"hello".equals("hello") == false`的情况,这不是我们想看到的,所以String类中会默认重写`equals`方法,对字符串是进行内容的比较,这也是为什么字符串为什么不能用`==`比较的原因

![](images/Object类中的方法/file-20250412191438.png)

![](images/Object类中的方法/file-20250412191701.png)

****

**(3) 写法顺序**

>因为`equals`是作为一个方法存在的,它必须由对象来调用才行,所以`.equals`前面不能为空对象,因此在使用的时候尽量把字符串放在`.`前面,确保这个方法能正常执行避免空指针异常

****

**(4) 类中重写equals**

>因为`equals`的特性,需要对它进行重写才能比较类中的内容而不是引用的指向

![](images/Object类中的方法/file-20250412195813.png)

![](images/Object类中的方法/file-20250412195802.png)

>因为是重写父类的方法,所以接收的值其实是`Object`类型,所以这里面必须进行一次向下转型才能访问当前对象中的字段

****

# 三.hashCode

>每个对象中都有一个默认的哈希码,哈希码主要是用来帮助快速查找对象,确定对象在哈希表中的哪个位置,`hashCode`方法就是用来返回对象的内存地址的哈希值的

**(1) 重写equals往往伴随重写hashCode**

>在类中重写`equals`方法时通常需要一起重写`hashCode`方法,因为Java官方规定两个对象相等的话它们的哈希值也要相等,所以重写`equals`方法让它们在逻辑上相等时也需要让它们的`hashCode`方法返回相等的哈希值

>这两个对象只是在逻辑上相等,实际上在内存空间拥有独立的地址,但是重写的`hashCode`不管,因为你们在逻辑上相等,所以就必须有相同的哈希码,如果两个相同的对象拥有不同的哈希值时Java就会认为它们不是同一个对象,就会返回`false`

![](images/Object类中的方法/file-20250412205130.png)



![](images/Object类中的方法/file-20250412205201.png)

****


