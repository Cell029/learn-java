
# 一.算法

## 1.1定义

>算法是描述解决问题的方法，对于程序来说，算法是完成特定任务的指令，对于Java来说，算法是一种可以被封装的特殊对象，降算法封装到类中，构成了传说中的工具类

****

## 1.2五大特性

#### 1.2.1输入输出

>算法是对特定问题的一种优秀的解决手段，想要解决这个问题当然要先提出问题，输入就类似于提出问题，而输出就像是经过算法处理后的数据，也就是问题的答案，所以输入和输出就是算法的入口与出口，具有完整结构的算法才具有被封装的可能

****

#### 1.2.2有穷性

>算法是一定要可以正常运行完的，不能说它有了入口后就没有停止条件，变成了死循环，那就一直得不到结果，没有结构就无法验证算法的正确性，所以必须规定算法是有穷的

****

#### 1.2.3可行性

>算法中不能存在模糊、意义不明或者不能执行的步骤，它必让使用者可以读懂才行，就像Java语言中定义了很多贵伐，只有遵守了这些规范才能让JVM解析`.class`文件，这样才能算得上一个完整的程序，算法也是如此，不遵守规范的算法只能算是一段无意义的字母

****

#### 1.2.4确定性

>算法在拥有相同的输入与限制条件时，必须输出相同的结果，这样才算得上是一个可执行的算法，若输出不同证明算法的逻辑是存在问题的，存在问题的算法是不能使用的

****
# 二.时间复杂度

## 2.1定义

>时间复杂度是用来评判一个算法是否优秀的标准之一，以输入的n表示算法需要执行的操作数（规模），在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，这个函数也被叫做时间频度，通过分析T(n)随n的变化情况来确定T(n)的数量级

>算法的时间复杂度公式：T(n)=O(f(n))。它表示随着问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，O(f(n))被称作时间复杂度，也被称作大O表示法

****

## 2.2计算步骤

>一般情况下都是按照算法的最坏情况计算的，此时的执行操作一般是最多的

>在计算时间复杂度的前提是确认T(n)，T(n)一般是一个函数，例如T(n)=4n<sup>2</sup>+2n+1，f(n)=n<sup>2</sup>，就是取函数的最高次幂，忽略系数就行，此时O(f(n))=O(n<sup>2</sup>)，时间复杂度也就是O(n<sup>2</sup>)

>但是时间频度不同却可能拥有相同的时间复杂度，因为时间复杂度取的是最高次幂，忽略掉了很多东西，所以只要时间频度函数的最高次幂相同，它们的时间复杂度就相同

****

## 2.3常见时间复杂度

#### 2.3.1常数阶O(1)

>常数在坐标轴中的表示就是一根水平直线，所以常数阶的时间复杂度与算法的输入规模无关，此时的算法是没有复杂的循环结构，不管执行多少行使用的时间都是一样的

```java
for (int i = 0; i < 5; i++) {
    sum += arr[i]; 
}
```

>常数阶的时间复杂度本质上是会影响算法的，但是它常常会被忽略，因为它与输入的规模无关，而O(f(n))关心的东西是与n挂钩的，所以常数阶并不会改变算法的增长趋势

>但是并不是相同算法的常数阶都一样，它取决于硬件的性能、使用的语言等都会导致相同的算法的时间复杂度不同，但往往可以忽略

****

#### 2.3.2对数阶O(log n)

>拿二分查找算法举例

```java
public int binarySearch(int[] arr, int target) {
    int left = 0, right = arr.length - 1;
    while (left <= right) {
        int mid = (left + right) / 2;
        if (arr[mid] == target) return mid;
        else if (arr[mid] < target) left = mid + 1;
        else right = mid - 1;
    }
    return -1;
}
```

>最开始的搜索区间是整个数组，大小是n，每次查找都会把搜索区间变成原来的1/2，当一个区间最多支持k次查找时，就会出现  
>n -> n/2 -> n/4 -> ··· -> n/2<sup>k</sup>  
>因为最后的查找只会找到一个元素，所以第k次的查找区间一定是1，所以  
>n/2<sup>k</sup> = 1，即n = 2<sup>k</sup> ，反推一下可以得到 k = log<sub>2</sub>n，因为k是最多的循环次数，也就是说这个算法最多支持 log<sub>2</sub>n 次查找，也就是说T(n)=log<sub>2</sub>n，所以时间复杂度O(n) = O(log<sub>2</sub>n)，通常对数阶都会忽略底数，直接写成O(log n)

****

#### 2.3.3线性阶O(n)

>如果输入的规模是n，并且算法需要执行大约n次，那么这个算法的时间复杂度就是O(n)，比如一个常见的循环一般都是O(n)

```java
for (int i = 0; i < arr.length; i++) {
        if (arr[i] == target) return i;
    }
```

****

#### 2.3.4线性对数阶O(nlog n)

>算法的总执行次数是输入规模n与log n的乘积，常见的就是归并排序

```java 
原始数组：
[8, 4, 5, 7, 1, 3, 6, 2]                     ···1

第一轮划分：
[8, 4, 5, 7]        [1, 3, 6, 2]             ···2

继续划分：
[8, 4]  [5, 7]      [1, 3]  [6, 2]           ···3

继续划分到最小单元：
[8] [4] [5] [7]     [1] [3] [6] [2]          ···4（拆分）/1（合并）

开始合并（并排序）：
[4, 8]  [5, 7]      [1, 3]  [2, 6]           ···2

继续合并：
[4, 5, 7, 8]        [1, 2, 3, 6]             ···3

最终合并为：
[1, 2, 3, 4, 5, 6, 7, 8]                     ···4
```

>假设划分过程最多需要k次（k层），每次划分都会把数组一分为二，所以直到划分为一个元素时  
>n -> n/2 -> n/4 -> ··· -> n/2<sup>k</sup>， n/2<sup>k</sup> = 1，所以 k = log<sub>2</sub>n，所以整个拆分和合并的高度都是log<sub>2</sub>n  
>因为拆分过程没有比较元素大小的情况，所以不计算比较次数，只有拆分次数  

**第一层合并**

>8和4对比，放入`[4,8]`，1次比较  
>5和7对比，放入`[5,7]`，1次比较  
>1和3对比，放入`[1,3]`，1次比较  
>6和2对比，放入`[2,6]`，1次比较  
>第一层合并一共进行4次比较

**第二层合并**

>4和5对比，4放入新数组  
>8和5对比，5放入新数组  
>8和7对比，7放入新数组  
>同理右边两个数组也要进行3次对比，所以第二层合并进行6次比较

**第三层合并**

>4和1对比，1放入新数组  
>4和2对比，2放入新数组  
>4和3对比，3放入新数组  
>4和6对比，4放入新数组  
>5和6对比，5放入新数组  
>7和6对比，6放入新数组  
>7和8对比，7放入新数组  
>第三层合并进行7次比较

>每一层合并的比较次数都会根据子数组的大小而不同，子数组中元素越多，需要比较的次数也就越多，因为元素的个数是n，所以可以把比较的次数看作与n线性相关，所以可以把每层的比较次数近似看成n次

>总共有log<sub>2</sub>n层，所以共需要比较 nlog<sub>2</sub>n 次，即时间复杂度为O(nlog<sub>2</sub>n) 

****

#### 2.3.5平方阶O(n<sup>2</sup>)

>当一个算法处理n个数据时需要执行n<sup>2</sup>次操作，那么这个算法的时间复杂度就是O(n<sup>2</sup>)，常见的就是冒泡算法

```java 
public class BubbleSort {
    public static void bubbleSort(int[] arr) {
        int n = arr.length;
        for (int i = 0; i < n - 1; i++) {
            for (int j = 0; j < n - 1 - i; j++) {
                if (arr[j] > arr[j + 1]) {
                    int temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                }
            }
        }
    }
}
```

>当i=0时，内层循环会循环n-1次，当i=1时，内层循环会循环n-2次，以此类推，i总共会取n-1次值，所以总共会调用n-1次内层的for语句，所以可以得到  
>(n-1) + (n-2) + ··· + 2 + 1 = n(n-1)/2 = n<sup>2</sup>/2 - n/2，所以时间复杂度为O(n<sup>2</sup>)

>核心过程就是存在一个嵌套循环，每个元素都会进行对比，n个元素对比n次就成了n<sup>2</sup>

****

#### 2.3.6指数阶O(2<sup>n</sup>)

>指数阶的算法在输入的规模较大时运行速度就会非常的慢，几乎无法实际使用，例如常见的斐波那契数列

```java
public class Fibonacci {
    public static int fib(int n) {
        if (n == 0) return 0;
        if (n == 1) return 1;
        return fib(n - 1) + fib(n - 2);
    }
}
```

```
	          fib(5)
	         /      \
	     fib(4)     fib(3)
	     /   \       /   \
	 fib(3) fib(2) fib(2) fib(1)
	  /  \    ...     ...
 fib(2)  ...
```

>这种结构类似于一颗二叉树，所以可以把调用函数的次数看作是满二叉树的节点数，所以有  
>1 + 2 + 4 + ··· + 2<sup>h</sup> = 2<sup>h+1</sup> - 1，所以斐波那契数列的时间复杂度可以近似看作O(2<sup>n</sup>)

>所以指数阶的实现过程核心是爆炸式递归分裂

****

#### 2.3.7阶乘阶(n!)

>n! = n·(n-1)·(n-2)· ··· ·2·1，例如打印n个数字的所有排列，  
>第1个数字可以有n中选择，第2个数字可以有(n-1)中...  

****


