
# 一.算法

## 1.1定义

>算法是描述解决问题的方法，对于程序来说，算法是完成特定任务的指令，对于Java来说，算法是一种可以被封装的特殊对象，降算法封装到类中，构成了传说中的工具类

****

## 1.2五大特性

#### 1.2.1输入输出

>算法是对特定问题的一种优秀的解决手段，想要解决这个问题当然要先提出问题，输入就类似于提出问题，而输出就像是经过算法处理后的数据，也就是问题的答案，所以输入和输出就是算法的入口与出口，具有完整结构的算法才具有被封装的可能

****

#### 1.2.2有穷性

>算法是一定要可以正常运行完的，不能说它有了入口后就没有停止条件，变成了死循环，那就一直得不到结果，没有结构就无法验证算法的正确性，所以必须规定算法是有穷的

****

#### 1.2.3可行性

>算法中不能存在模糊、意义不明或者不能执行的步骤，它必让使用者可以读懂才行，就像Java语言中定义了很多贵伐，只有遵守了这些规范才能让JVM解析`.class`文件，这样才能算得上一个完整的程序，算法也是如此，不遵守规范的算法只能算是一段无意义的字母

****

#### 1.2.4确定性

>算法在拥有相同的输入与限制条件时，必须输出相同的结果，这样才算得上是一个可执行的算法，若输出不同证明算法的逻辑是存在问题的，存在问题的算法是不能使用的

****
# 二.时间复杂度

## 2.1定义

>时间复杂度是用来评判一个算法是否优秀的标准之一，以输入的n表示算法需要执行的操作数（规模），在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，这个函数也被叫做时间频度，通过分析T(n)随n的变化情况来确定T(n)的数量级

>算法的时间复杂度公式：T(n)=O(f(n))。它表示随着问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，O(f(n))被称作时间复杂度，也被称作大O表示法

****

## 2.2计算步骤

>一般情况下都是按照算法的最坏情况计算的，此时的执行操作一般是最多的

>在计算时间复杂度的前提是确认T(n)，T(n)一般是一个函数，例如T(n)=4n<sup>2</sup>+2n+1，f(n)=n<sup>2</sup>，就是取函数的最高次幂，忽略系数就行，此时O(f(n))=O(n<sup>2</sup>)，时间复杂度也就是O(n<sup>2</sup>)

>但是时间频度不同却可能拥有相同的时间复杂度，因为时间复杂度取的是最高次幂，忽略掉了很多东西，所以只要时间频度函数的最高次幂相同，它们的时间复杂度就相同

****

## 2.3常见时间复杂度

#### 2.3.1常数阶O(1)

>常数在坐标轴中的表示就是一根水平直线，所以常数阶的时间复杂度与算法的输入规模无关，此时的算法是没有复杂的循环结构，不管执行多少行使用的时间都是一样的

```java
for (int i = 0; i < 5; i++) {
    sum += arr[i]; 
}
```

>常数阶的时间复杂度本质上是会影响算法的，但是它常常会被忽略，因为它与输入的规模无关，而O(f(n))关心的东西是与n挂钩的，所以常数阶并不会改变算法的增长趋势

>但是并不是相同算法的常数阶都一样，它取决于硬件的性能、使用的语言等都会导致相同的算法的时间复杂度不同，但往往可以忽略

****

#### 2.3.2对数阶O(log<sub>2</sub>n)

>拿二分查找算法举例

```java
public int binarySearch(int[] arr, int target) {
    int left = 0, right = arr.length - 1;
    while (left <= right) {
        int mid = (left + right) / 2;
        if (arr[mid] == target) return mid;
        else if (arr[mid] < target) left = mid + 1;
        else right = mid - 1;
    }
    return -1;
}
```

>最开始的搜索区间是整个数组，大小是n，每次查找都会把搜索区间变成原来的1/2，当一个区间最多支持k次查找时，就会出现  
>n -> n/2 -> n/4 -> ··· -> n/2<sup>k</sup>  
>因为最后的查找只会找到一个元素，所以第k次的查找区间一定是1，所以  
>n/2<sup>k</sup> = 1，即n = 2<sup>k</sup> ，反推一下可以得到 k = log<sub>2</sub>n，因为k是最多的循环次数，也就是说这个算法最多支持 log<sub>2</sub>n 次查找，也就是说T(n)=log<sub>2</sub>n，所以时间复杂度O(n) = O(log<sub>2</sub>n)

****

#### 2.3.3线性阶

>
