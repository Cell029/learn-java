
## 1. 基本数据类型与包装类的对应关系

```
 byte       Byte      
 short      Short     
 int        Integer   
 long       Long      
 float      Float     
 double     Double    
 char       Character 
 boolean    Boolean   
```

****
## 2. 为什么引入包装类

### 2.1 让基本数据类型可以像对象一样使用

>Java是面向对象的编程，这就导致基本数据类型不能直接参与面向对象的操作，例如集合（`List`、`Map`）只能存储对象，不能存储基本类型，所以引入包装类，让基本数据类型具有对象的特性

****
### 2.2 允许null值

>基本类型不能为`null`，而包装类可以表示“**值缺失**”或“**未定义**”的场景：

```java
Integer age = getUserAgeFromDatabase(); 

if (age == null) {
    System.out.println("年龄未填写");
}
```

****

## 3. 装箱与拆箱

>装箱：将基本数据类型转换为对应的包装类对象  
>拆箱：将包装类对象转换回基本数据类型

### 3.1 自动装箱与拆箱

#### 3.1.1 自动装箱

```java
int num = 10;

Integer i = num;        // 自动装箱：int → Integer
                        // 等于Integer obj = Integer.valueOf(num)
int val = i;            // 自动拆箱：Integer → int
                        // 等于int val = obj.intValue()
```

>在集合中就存在自动装箱与拆箱的过程

```java
List<Integer> list = new ArrayList<>();
list.add(123);        // 自动装箱
int n = list.get(0);  // 自动拆箱
```

>需要注意的是Java 为了优化内存和性能，对于频繁使用的小整数对象（`Integer` 类型）进行了缓存机制，Java 默认缓存的是 -128 到 127 之间的整数对象

```Java
Integer a = 127;
Integer b = 127;
System.out.println(a == b);      // true（引用同一个对象）
Integer x = 128;
Integer y = 128;
System.out.println(x == y);      // false（超出缓存范围）
System.out.println(x.equals(y)); // true（比较内容）
```

![](images/包装类/file-20250423210137.png)

![](images/包装类/file-20250423210302.png)

![](images/包装类/file-20250423210008.png)

>这些缓存实际上是存放在一个数组中的，当调用 valueOf 时

| 包装类              | 是否有缓存机制 | 默认缓存范围              |
| ---------------- | ------- | ------------------- |
| **Integer**      | 是       | -128 ~ 127（可调）      |
| **Short**        | 是       | -128 ~ 127          |
| **Byte**         | 是       | 所有值（-128 ~ 127）     |
| **Long**         | 是       | -128 ~ 127          |
| **Character**    | 是       | 0 ~ 127（ASCII）      |
| **Boolean**      | 是       | `true` / `false` 两个 |
| **Float/Double** | 否       | 没有缓存机制（使用频率低）       |

****

#### 3.1.2 自动拆箱

