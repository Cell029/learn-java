
# 一.类

>类是对象的设计图,定义了对象的属性和行为,描述一类对象的共同特征,类是某中事物的抽象定义

## 1.类的加载

>这个过程是jvm将.class文件读进内存的过程

>jvm会先找到.class文件,然后把这个文件存入方法区或运行时数据区,将.class文件转换成Class对象

>jvm读取.class文件的内容,把类中的信息存放在方法区(Java8之前)/元空间(Java8之后)中,然后把创建好的Class对象存放在堆内存中

>所以说类的创建本身也是一种对象的创建,程序员写的类在加载时都会被加载成一个Class<类>类型的对象,这个对象就代表它本身这个类的结构和行为

```
例如创建一个Person类
class Person {
}

底层运行
Class<Person> 
```

>既然每个类在加载时都会被创建成一个Class类型的对象,那证明多个对象共享一个Class,就跟创建一个普通的对象一样,可以new很多个

**Class对象怎么来的?**

>Class也是个普通的类,只不过是由官方写出来的,在编译时也是个.class文件,目前只知道这个应该够了...

## 2.类的连接

>验证字节码是否合法,给静态变量分配内存空间并设置默认值


## 3.类的初始化

>执行类的静态初始化块和静态变量赋初值
# 二.对象

>类的实例化,具有类的属性和方法

## 1.jvm内存分布(简易版)

>jvm主要的三个空间为:虚拟机栈,堆,方法区的实现(元空间)

**虚拟机栈**

>用来存储调用的方法的信息,每调用一个方法就会入栈一个栈帧,方法执行完就出栈,栈帧中包含了方法中的局部变量,操作数栈等东西

```
int i = 10;
Person p1 = new Person();
这两个都是局部变量,全部储存在栈帧中,只不过基本数据类型储存的就是值,而引用数据类型储存的却是一个地址,这个地址用来指向存放在堆中的信息
```

**堆**

>主要用来存放实例变量,也就是new出来的东西,这个变量里面会存储类的属性和方法,想要访问这些数据就需要知道这个变量的地址,也就是在栈帧中存储这个对象的地址,这也是为什么引用数据类型可以在方法中更改数据不受局部变量影响

**元空间**

>元空间存储的是类的元信息和字节码等,使用的是本地的内存,所有类的结构信息都会放进这里,并不只是new出来的才放进来,而大家共享的Class对象也在这个地方

## 2.创建对象

>通常使用new来创建一个实例对象

```
Person person = new Person();
这个person是引用变量,不存储真实的Person信息,它指向堆内存中的Person对象
```

>所以需要区分,放在栈中的是引用,放在堆中的是对象,引用是保存对象地址的变量,对象是被new出来的,需要借助 对象名(引用).属性名/方法名 来访问对象的信息

**Person person = new Person()**

>创建时首先会寻找.class文件,先从文件路径中找,也就是那个默认的地方,然后再从类路径中找,也就是各种导入和jar包,找到后就转换成Class对象,转换成Class对象后jvm就知道了你这个Person对象的结构是什么样的了,然后就可以通过类中的构造器来初始化字段(各种信息)然后才会放进堆中,最后把这个对象的地址返回给引用变量

**构造方法**

>jvm怎么知道我new的对象的构造方法是什么的呢?使用类中的方法不应该用 对象.方法名 来访问吗?

```Java
//编译器的转换字节码阶段
new           #2   → 从常量池加载类（Class 对象）,创建一个半成品对象,还没初始化
dup                 → 复制对象引用，为构造器调用准备
invokespecial #3   → 执行 `<init>` 方法（也在常量池,也就是元空间中）
```

```Java
person.sayHi();//调用对象的方法

aload_1              //把 person 对象加载到栈顶
invokevirtual #5     //从常量池调用 sayHi() 方法,#5 是常量池中 sayHi 方法的描述信息
```

>通过以上代码,可以看到,jvm在初始化或者调用对象的方法时,根本不是根据 对象名.方法名 来找到某个方法的,而是通过 对象名 这个引用变量(存放的真实对象的地址) 来找到堆中的信息,所以new对象时写的那个引用变量实际没什么用,写成person只是更好的知道当前创建的是Person对象

>所以调用构造器时,根据里面的参数列表,决定需要初始化的字段,没有的就使用成员变量的默认值,有的就根据里面的 this.name = "jack" 来赋值

```
修饰符 构造器名(参数列表)
需要注意的是,构造器不需要写返回类型,也不需要写return语句,但是他可以返回创建的对象的内存地址
这是和普通方法的最大区别,当没有手动写一个带参数的构造器时,系统会默认创建一个无参的构造器
```

**构造代码块**

>每一次new对象都会先执行一次代码块,并且在构造方法执行前执行的,调用方法时不会调用

```
{
	代码;
}
```

>构造代码块通常是用于多个构造器之间的统一初始化逻辑,例如打印日志,安全检查等,但是如果多个构造器的初始化逻辑不同,就不适用

