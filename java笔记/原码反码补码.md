# 一.byte与bit

>byte是字节,bit是比特,一个字节由8个二进制位组成,一个二进制位就是一个比特.所以八个比特位就是一个字节.

>计算机中数据以字节为单位传输,存储,比特则是用来表示数据的最小单位

>1KB=2<sup>10</sup>B=2<sup>3</sup>x2<sup>10</sup>bit

# 二.原码反码补码

>最高位为符号位,0为正,1为负

## 1.原码

>符号位加上真值的绝对值,例如8位二进制:  
>[+1]<sub>原</sub>=0 000 0001  
>[-1]<sub>原</sub>=1 000 0001  
>因为最高位是符号位,所以最大值应该是 0 111 1111,最小值 1 000 0000,也就是[-127,127]

## 2.反码

>正数的反码是本身,负数的反码是在原码的基础上,符号位不变,其余取反  
>[+1]<sub>反</sub>=0 000 0001  
>[-1]<sub>反</sub>=1 111 1110

## 3.补码

>正数的补码是本身,负数的补码是在反码的基础上+1  
>[+1]<sub>补</sub>=0 000 0001  
>[-1]<sub>补</sub>=1 111 1111

>需要注意的是,-128的原码与补码相同,-128实际为1 0000 0000,但是一个字节只有8个二进制位,所以应该为 0000 0000,但是最高位是符号位,所以应该表示为 1 000 0000,这就导致-128的原补码相同

>[-128]<sub>原</sub>=1 000 0000  
>[-128]<sub>补</sub>=1 000 0000

# 三.计算机底层为什么要使用人类难以看懂的补码

## 1.统一运算

>因为计算机中,最高位是符号位,直接用原码计算容易出错,例如:  
>[+1]<sub>原</sub>=0 000 0001  + [-1]<sub>原</sub>=1 000 0001 = 1000 0010 = [-2]<sub>原</sub>  
>这明显是错的,但是使用补码进行运算的话就是正确的,例如:  
>[+1]<sub>补</sub>=0 000 0001  + [-1]<sub>补</sub>=1 111 1111 = 1000 0000 = 0000 0000 = [0]<sub>原</sub>

## 2.0的二义性

>原码表示0有两种方式:  
>* +0=0000 0000  
>* -0=1000 0000  
>但是补码只有一种方式:  
>+0=0000 0000  
>取反后加1,-0=0000 0000

## 3.-128

>-128有原码,但不用于计算,因为-128的原码和-0的原码一样  
>[-0]<sub>原</sub>=1 000 0000  
>[-128]<sub>原</sub>=1 000 0000,因为在原码中 1 000 0000实际上无效,第一位是符号位,后面七位才是用来存储数据的,所以数值部分智能表示0~127,无法正确表示128,但补码可以,因为 -2<sup>7</sup> = -128

>所以原码的取值范围是[-127,127],补码的取值范围是[-128,127],托补码的福,计算机可以表示256个不同的二进制码,比原码多一位