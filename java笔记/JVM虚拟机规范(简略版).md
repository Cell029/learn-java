
# 一.JVM规范中的运行时数据区

>1. The PC Register(程序计数器):记录正在执行的虚拟机字节码指令的地址
>2. Java Virtual Machine Stacks(Java虚拟机栈):存储栈帧.栈帧里面存储局部变量表,操作数栈,动态链接,方法出口信息等.
>3. Heap(堆):Java虚拟机管理的最大一块内存,存放Java对象实例和数组,堆是垃圾收集器收集垃圾的主要区域
>4. Method Area(方法区):存储已被虚拟机加载的类的信息,常量,静态变量等
>5. Run-Time Constant Pool(运行时常量池):方法区的一部分,存放编译期生成的字面量与符号引用(方法区中)
>6. Native Method Stacks(本地方法栈):在本地方法的执行过程中会使用到,与Java虚拟机栈十分相似,

**HotSpot**

>HotSpot是Oracle公司开发的,目前最常用的虚拟机实现,也是默认的Java虚拟机
# 二.jdk6的HotSpot

![](images/JVM虚拟机规范(简略版)/file-20250408211046.png)

>刚new出来的对象就放在年轻代中,经过垃圾回收后,有些对象可能没有被释放,就会被放在老年代中

>jkd6时的永久代和方法区在物理上是相邻的(使用连续的物理内存),但逻辑上是隔离的(内存空间)

>永久代的垃圾收集和老年代捆绑在一起,无论谁满了都会触发垃圾收集


# 三.jdk7的HotSpot

![](images/JVM虚拟机规范(简略版)/file-20250408211956.png)

>因为在jdk6中,很多东西都放在永久代中,当写的程序足够大时,就容易发生内存溢出(Out Of Memory),所以把一些东西从永久代中拿走了

>主要就是引入了本地内存,为jdk8打基础

# 四.jdk8的HotSpot

![](images/JVM虚拟机规范(简略版)/file-20250408213531.png)

>在JVM的规范中类的信息,常量,静态变量是放在方法区的,但是每个语言有自己的一套实现方法,所以Java语言选择了把这些信息放在了堆中,但是类的字节码信息还是在方法区中
# 五.垃圾回收机制

>JVM释放无用对象所占内存的过程,Java会自动释放,无需手动

>JVM会用到一种叫可达性分析的算法,它能找到没有被直接或者间接引用的对象,然后判定它们为垃圾,在jdk8之后,垃圾回收主要是在堆中进行,因为new出来的对象都放在这了


# 六.符号引用

>JVM 在还没真正运行、还没加载某个类/方法/字段的时候，只是用名字来象征性地表示某个类/方法/字段的位置

>在编译阶段,JVM并不知道类的实际地址,所以才会使用符号引用在来作为一个地址的描述,这个描述会存在字节码文件中作为一个模糊的地址(编译阶段)

>JVM在运行时会从字节码文件中找到某个类的模糊地址,然后再借助classpath找到.class文件,加载进内存,获取到真正的地址

>所以说类的符号引用就是类的全限定名(java/lang/String)  
>字段的符号引用是：类全名 + 字段名 + 字段类型(java/lang/System.out:Ljava/io/PrintStream)  
>方法的符号引用是：类全名 + 方法名 + 方法签名(java/io/PrintStream.println:(Ljava/lang/String;)V)

![](images/JVM虚拟机规范(简略版)/file-20250408221942.png)


# 七.直接引用

>类加载之后，JVM 通过符号引用解析出的“真实地址”，也就是指向内存中对象、方法的直接指针

>在类的初始化之后,首次使用字段/方法/类时就会把符号引用转成直接引用,根据不同的类型,直接引用会存放在不同的地方,new对象就会放在Java虚拟机栈的局部变量表中(那个引用变量),对象的内容的直接引用就放在堆中,方法的就放在方法区中

**为什么方法的直接引用放在方法区中,不是堆中?**

>我又搞混了一个概念,方法是属于类的,不属于对象,所以方法的入口是属于类级别的信息,自然要放在方法区中,对象只是保存某些数据字段

**既然方法是类级别的,那为什么使用某些实例方法需要new一个对象而不是直接用类来访问呢?**

>因为实例方法需要依赖对象的字段信息来运行,所以必须有具体对象,但静态方法不依赖对象的状态,所以可以直接通过类来访问

>所以Java虚拟机栈中的引用存放的是堆中对象的地址,通过这个地址找到new的对象,堆中的对象结构包含一个**对象头**,对象头里有一个指向所属类的元数据指针,通过这个指针来访问实例方法,所以方法是通过"对象->类->方法"间接访问

**对象头指向方法也需要空间,这和直接放方法到堆中有什么区别**

>因为在方法区中会存放一个方法表,专门存放某个类的所有方法,所以只需要通过对象头来访问这个方法表就可以了,就等于说只需要一个地址就可以访问所有方法,如果是直接把方法放在堆中的每个对象里,那每次new一个对象就需要把所有的方法的入口放在堆里,那占据的空间一下就大了,所以可以通过这种机制来减少不必要的空间,就有点像代码复用的机制