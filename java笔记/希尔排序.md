
>希尔排序是插入排序的改进版本，也叫缩小增量排序

>希尔排序会将数组按照一定的间隔进行分组，对每组分别进行插入排序，完成后再减小每组的间隔，直到间隔为1，也就是对整个数组进行插入排序

>通常这个数组的间隔叫做增量，初始值为数组长度的一半，每次排序完都会继续减半，直到为1为止

```
[23, 12, 1, 8, 34, 54, 2]

取增量gap=7/2=3，
序列1：arr[0], arr[3], arr[6] → [23, 8, 2]
组内插入排序：[8, 23, 2] → [8, 2, 23] → [2, 8, 23]
序列2：arr[1], arr[4] → [12, 34]
组内插入排序：[12, 34]
序列3：arr[2], arr[5] → [1, 54]
组内插入排序：[1, 54]
此时数组：[2, 12, 1, 8, 34, 54, 23]

取增量gap=3/2=1
此时增量为1，直接对整个数组进行插入排序
[2, 12, 1, 8, 34, 54, 23] → [1, 2, 12, 8, 34, 54, 23] → [1, 2, 8, 12, 34, 54, 23] → [1, 2, 8, 12, 23, 34, 54]
```

```java
private static void shellSort(int[] arr) {  
    int n = arr.length;  
    for (int gap = n / 2; gap > 0; gap /= 2) {
    //每轮循环之后，将 gap 缩小为一半，直到最后变成 1，也就是普通插入排序的过程  
        for (int i = gap; i < n; i++) {  
            //因为第一个元素默认是有序的，所以直接从i=gap开始，
            //也就是组内的当前要插入的元素，后续i++就是进入下一个分组  
            int key = arr[i];  
            int j = i - gap;//表示组内元素的前一个元素  
            while (j >= 0 && arr[j] > key) {  
                arr[j + gap] = arr[j];  
                j -= gap;//每次前移一个gap，也就是组内的元素的前一个元素
			               
            }  
            arr[j + gap] = key; 
            //while循环结束后，j已经指向比key小（或等于）的那个元素的位置，
			//所以key应该插入到j的下一个gap位置（即 j + gap）
			//这也是之前向后挪动元素所留下的“空位”
        }  
    }  
}
```

>插入排序在数组部分有序的情况下效率是较高的，希尔排序就是利用了这个特性，把数组中的元素提前让它们实现部分有序，从而提高插入排序的效率，这也是为什么最后的增量必须设置成1才行

>插入排序是有序的，因为两个元素不存在大小关系时是不会进行后移的，但是希尔排序会在分组时打乱一些元素的初始前后位置，所以会导致整个排序不稳定

**另一种代码实现方法**

```java
public static void shellSortGroup(int[] arr) {  
    int n = arr.length;  
    for (int gap = n / 2; gap > 0; gap /= 2) {  
        for (int start = 0; start < gap; start++) {  
            //因为每组的首个元素必须在第一组的第二个元素的前面，
            //而arr[gap]恰好是第一组的第二个元素，所以start必须小于gap  
            for (int i = start + gap; i < n; i += gap) {  
                int key = arr[i];  
                int j = i -gap;  
                while (j >= 0 && arr[j] > key) {  
                    arr[j + gap] = arr[j];  
                    j -= gap;  
                }  
                arr[j + gap] = key;  
            }  
        }  
    }  
}
```

>第一种只使用了两个for循环，而这种分组实现插入排序的方式使用了三个for循环，肉眼可见的效率低下

>它们的处理方式是不同的，这种实现方式是分组来的，也就是第一轮循环先实现序列1的排序，第二轮循环实现序列2的排序，以此类推，这种实现方式比较符合手动希尔排序的逻辑，比较好理解，但是效果上比较差

>第一种实现方式虽然容易弄懵，但是效率更高，i的每一次自增都是进入下一个分组的元素，然后用这个元素与它这组的上一个元素进行对比，然后选择后移，但是无论哪种都需要让j -= ga