>堆是一种完全二叉树，除了最后一层外每一层都填满，最后一层从左到右依次填充

## 1.堆

**大顶堆**

>任何一个非叶子结点的值都大于等于其左右孩子节点的值

**小顶堆**

>任何一个非叶子结点的值都小于等于其左右孩子节点的值


>堆通常用数组来表示，当下标从1开始时，父节点下标为 i / 2，左孩子 2i，右孩子 2i + 1  
>当下标从0开始，父节点下标为 (i-1) / 2，左孩子 2i + 1，右孩子 2i + 2

**大顶堆的构建**

>从最后一个非叶子节点开始，比较当前节点与孩子节点的大小关系，如果没有孩子节点大，就从两个孩子节点中挑较大的那个互换位置，按照顺序依次向上调整，当两个非叶子节点互换位置后，需要判断互换后是否仍然满足大顶堆的特性，不满足就继续和孩子节点互换

```java
/**  
 * 创建大顶堆  
 * @param arr  
 */  
public static void buildMaxHeap(int[] arr) {  
    int n = arr.length;  
    // 从最后一个非叶子节点开始判断，依次往上  
    // 最后一个非叶子节点的下标是 n/2 - 1 （数组下标从0开始）  
    for (int i = n / 2 - 1; i >= 0; i--) {  
        heapify(arr, n, i);  
    }  
}  
  
/**  
 * 下沉操作，将父节点替换成最大的，替换后继续判断被替换的那个节点是否满足大顶堆特性  
 * @param arr  
 * @param heapSize  
 * @param i  
 */  
public static void heapify(int[] arr, int heapSize, int i) {  
    int largest = i;// 假设当前节点是最大节点  
    int left = 2 * i + 1;// 左孩子  
    int right = 2* i + 2;// 右孩子  
  
    // 判断当前节点是否有左孩子，如果左孩子的下标超过数组证明没有左孩子  
    // 当左孩子的值比当前最大节点大，就将 largest 指向左孩子  
    if(left < heapSize && arr[left] > arr[largest]) {  
        largest = left;// 将 largest 指向左孩子
    }  
    if(right < heapSize && arr[right] > arr[largest]) {  
        largest = right;  
    }  
  
    // 当 largest 指向的不是传进来的父节点时，证明此时的子树不满足大顶堆的特性，  
    // 需要进行交换操作，将父节点与 largest 指向的节点进行元素的交换  
    if(largest != i) {  
        swap(arr, largest, i);  
        // 交换完成后需要判断被交换的那个子节点的子树是否满足特性，因此把 largest 指向的节点当作下一个子树的父节点进行递归检查  
        heapify(arr,heapSize, largest);  
    }  
}  
  
private static void swap(int[] arr, int i, int j) {  
    int temp = arr[i];  
    arr[i] = arr[j];  
    arr[j] = temp;  
}
```

**小顶堆的构建**

>与大顶堆类似，父节点一定要比左右孩子小，并且交换完父节点后继续判断被交换的子节点是否符合特性

```java
public static void buildMinHeap(int[] arr) {  
    int n = arr.length;  
    for (int i = n / 2 - 1; i >= 0; i--) {  
        heapify(arr, n, i);  
    }  
}  
  
public static void heapify(int[] arr, int heapSize, int heapIndex) {  
    int smallest = heapIndex;  
    int left = 2 * heapIndex + 1;  
    int right = 2 * heapIndex + 2;  
  
    if (left < heapSize && arr[left] < arr[smallest]) {  
        smallest = left;  
    }  
    if (right < heapSize && arr[right] < arr[smallest]) {  
        smallest = right;  
    }  
  
    if (smallest != heapIndex) {  
        swap(arr, heapIndex, smallest);  
        heapify(arr, heapSize, smallest);  
    }  
}  
  
public static void swap(int[] arr, int i, int j) {  
    int temp = arr[i];  
    arr[i] = arr[j];  
    arr[j] = temp;  
}
```


## 2.堆排序

>堆排序的实现需要建立在堆的基础上

>构建好大顶堆后，将对堆顶（最大值）与当前堆的最后一个元素互换位置，然后不再管当前“最大”元素的位置，交换后可能会破坏大顶堆的特性，所以需要重新调整一下结构，然后继续将堆顶元素与最后一个元素互换位置，每一轮的交换都可以确定当前的最大值的位置，直到只剩一个元素

```java
public static void heapSort(int[] arr) {  
    int heapSize = arr.length;  
      
    // 先将数组处理成大顶堆的格式  
    for (int i = heapSize / 2 - 1; i >= 0; i--) {  
        heapify(arr, heapSize, i);  
    }  
  
    // 从最后一个元素开始与堆顶元素交换，每次交换完都要对被交换的那个元素进行判断是否符合大顶堆的特性  
    for (int i = heapSize - 1; i>= 0; i--) {  
        swap(arr, i, 0);  
        // 下沉操作传入的 heapSize 是 i，因为经过交换操作后已经确定了一个最大元素的位置，  
        // 所以下沉的操作可以不用管最后一个元素了，所以每次传入的数组大小都要减一  
        heapify(arr, i, 0);  
    }  
}  
  
public static void heapify(int[] arr, int heapSize, int heapIndex) {  
    int largest = heapIndex;  
    int left = 2 * heapIndex + 1;  
    int right = 2 * heapIndex + 2;  
  
    if (left < heapSize && arr[left] > arr[largest]) {  
        largest = left;  
    }  
  
    if (right < heapSize && arr[right] > arr[largest]) {  
        largest = right;  
    }  
  
    if (largest != heapIndex) {  
        swap(arr, heapIndex, largest);  
        heapify(arr, heapSize, largest);  
    }  
}  
  
public static void swap(int[] arr, int i, int j) {  
    int temp = arr[i];  
    arr[i] = arr[j];  
    arr[j] = temp;  
}
```

>如果是要降序排序就可以使用小顶堆的结构

>堆排序主要分为两个阶段， 一个进行建堆，一个进行互换，建堆过程的最坏情况可能是每次都要从根节点下沉到堆的底部，所以跟堆的高度有关即 log n 级别，排序过程每次只能确定一个元素的位置，所以需要 n - 1 次操作才能完成排序，故时间复杂度为O(n·log n)

>因为堆排序存在元素下沉与互换的关系，两个相同的元素经过排序后可能具有不同的前后关系，所以堆排序是不稳定的