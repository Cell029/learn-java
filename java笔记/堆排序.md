>堆是一种完全二叉树，除了最后一层外每一层都填满，最后一层从左到右依次填充

## 1.堆

**大顶堆**

>任何一个非叶子结点的值都大于等于其左右孩子节点的值

**小顶堆**

>任何一个非叶子结点的值都小于等于其左右孩子节点的值


>堆通常用数组来表示，当下标从1开始时，父节点下标为 i / 2，左孩子 2i，右孩子 2i + 1  
>当下标从0开始，父节点下标为 (i-1) / 2，左孩子 2i + 1，右孩子 2i + 2

**大顶堆的构建**

>从最后一个非叶子节点开始，比较当前节点与孩子节点的大小关系，如果没有孩子节点大，就从两个孩子节点中挑较大的那个互换位置，按照顺序依次向上调整，当两个非叶子节点互换位置后，需要判断互换后是否仍然满足大顶堆的特性，不满足就继续和孩子节点互换

```java
/**  
 * 创建大顶堆  
 * @param arr  
 */  
public static void buildMaxHeap(int[] arr) {  
    int n = arr.length;  
    // 从最后一个非叶子节点开始判断，依次往上  
    // 最后一个非叶子节点的下标是 n/2 - 1 （数组下标从0开始）  
    for (int i = n / 2 - 1; i >= 0; i--) {  
        heapify(arr, n, i);  
    }  
}  
  
/**  
 * 下沉操作，将父节点替换成最大的，替换后继续判断被替换的那个节点是否满足大顶堆特性  
 * @param arr  
 * @param heapSize  
 * @param i  
 */  
public static void heapify(int[] arr, int heapSize, int i) {  
    int largest = i;// 假设当前节点是最大节点  
    int left = 2 * i + 1;// 左孩子  
    int right = 2* i + 2;// 右孩子  
  
    // 判断当前节点是否有左孩子，如果左孩子的下标超过数组证明没有左孩子  
    // 当左孩子的值比当前最大节点大，就将 largest 指向左孩子  
    if(left < heapSize && arr[left] > arr[largest]) {  
        largest = left;// 将 largest 指向左孩子
    }  
    if(right < heapSize && arr[right] > arr[largest]) {  
        largest = right;  
    }  
  
    // 当 largest 指向的不是传进来的父节点时，证明此时的子树不满足大顶堆的特性，  
    // 需要进行交换操作，将父节点与 largest 指向的节点进行元素的交换  
    if(largest != i) {  
        swap(arr, largest, i);  
        // 交换完成后需要判断被交换的那个子节点的子树是否满足特性，因此把 largest 指向的节点当作下一个子树的父节点进行递归检查  
        heapify(arr,heapSize, largest);  
    }  
}  
  
private static void swap(int[] arr, int i, int j) {  
    int temp = arr[i];  
    arr[i] = arr[j];  
    arr[j] = temp;  
}
```

**小顶堆的构建**

>与大顶堆类似，父节点一定要比左右孩子小，并且交换完父节点后继续判断被交换的子节点是否符合特性

```java
public static void buildMinHeap(int[] arr) {  
    int n = arr.length;  
    for (int i = n / 2 - 1; i >= 0; i--) {  
        heapify(arr, n, i);  
    }  
}  
  
public static void heapify(int[] arr, int heapSize, int heapIndex) {  
    int smallest = heapIndex;  
    int left = 2 * heapIndex + 1;  
    int right = 2 * heapIndex + 2;  
  
    if (left < heapSize && arr[left] < arr[smallest]) {  
        smallest = left;  
    }  
    if (right < heapSize && arr[right] < arr[smallest]) {  
        smallest = right;  
    }  
  
    if (smallest != heapIndex) {  
        swap(arr, heapIndex, smallest);  
        heapify(arr, heapSize, smallest);  
    }  
}  
  
public static void swap(int[] arr, int i, int j) {  
    int temp = arr[i];  
    arr[i] = arr[j];  
    arr[j] = temp;  
}
```


## 2.堆排序

>堆排序的实现需要建立在堆的基础上

>构建好大顶堆后，将对堆顶（最大值）与当前堆的最后一个元素互换位置，然后不再管当前“最大”元素的位置，交换后可能会破坏大顶堆的特性，所以需要重新调整一下结构，然后继续将堆顶元素与最后一个元素互换位置，每一轮的交换都可以确定当前的最大值的位置，直到只剩一个元素