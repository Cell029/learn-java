
>选择一个基数作为比较的对象，通过一趟排序将数据分成两个部分，一部分小于基数，一部分大于基数，此时基数的位置就确定了，然后再对这两部分分别进行排序，重复操作，直到每个基数都确定位置，排序结束

![](images/快速排序/3eadbcc8e78529242f50173f4cb30003_720.png)

![](images/快速排序/afd16200a8240a7eb04d16701645786c_720.png)

![](images/快速排序/876e892ba185dfeeb623196e91e8195e_720.png)

![](images/快速排序/3d9639d7cb2348906a1a3753b0822325_720.png)

```java
public static void main(String[] args) {  
    int[] arr = {7, 2, 1, 6, 8, 5, 3, 4};  
    quickSort(arr, 0, arr.length - 1);  
    System.out.println(Arrays.toString(arr));  
}  
  
public static void quickSort(int[] arr, int left, int right) {  
    //当左指针和右指针重叠或者超过时，就终止程序，因为此时已经找到了基准值的位置  
    if (left >= right) {  
        return;  
    }  
    int pivot = arr[left];//选取当前子数组最左侧元素作为基准值（pivot）  
    int i = left, j = right;//为了递归时不破坏每个分组的边界值，使用两个指针 i 和 j，
						    //从两端向中间移动，避免直接修改 left 和 right  
    while (i < j) {  
        while (arr[j] > pivot && i < j) {//当右指针指向的元素大于基准值时，将右指针左移 
            j--;  
        }  
        // 找到比基准值小的元素，填入左边的空位（i 所在的位置）  
        if (i < j) {  
            arr[i] = arr[j];  
            i++;//做指针右移，接下来移动做指针  
        }  
        while (arr[i] < pivot && i < j) {  
            i++;  
        }  
        if (i < j) {  
            arr[j] = arr[i];  
            j--;  
        }  
    }  
    //循环结束证明此时 左指针==右指针，此时可以确定当前基准值的位置就是 i==j 的地方  
    arr[i] = pivot;  
    // 递归处理左右子数组，注意递归边界根据当前基准值位置动态变化  
    quickSort(arr, left, i - 1);  
    quickSort(arr, i + 1, right);  
}
```

>需要注意的是不能直接修改`left`和`right`两个指针，而是应该拿一对变量来接收它们，这是因为 `left` 和 `right` 的主要作用是在方法调用中明确表示当前排序区间的边界，它们是递归调用中用来确定左右分区范围的关键参数，如果它们随意改变的话，第一轮的调用就会导致它们无法准确的指向分组的边界，递归也无法正常运行

```java
public static void quickSort(int[] arr, int left, int right) {  
    if (left >= right) {  
        return;  
    }  
    int pivot = arr[left];
    while (left < right) {  
        while (arr[right] > pivot && left < right) {
            right--;  
        }  
        if (left < right) {  
            arr[left] = arr[right];  
            left++; 
        }  
        while (arr[left] < pivot && left < right) {  
            left++;  
        }  
        if (left < right) {  
            arr[right] = arr[left];  
            right--;  
        }  
    }   
    arr[left] = pivot;   
    quickSort(arr, left, i - 1);  
    quickSort(arr, i + 1, right);  
}
```