
>计数排序是一种非比较的排序，找出待排序数组中的最大值和最小值，计算排序所需的内存空间，通过建立一个大小为（最大值 - 最小值 + 1）的计数数组来实现，遍历待排序数组，对于每个元素，计数数组的值加 1，从计数数组的最低位开始，依次将数组元素值输出到原数组中

```java
public static void countingSort(int[] arr) {  
    int min = arr[0];  
    int max = arr[0];  
    for (int i = 0; i < arr.length; i++) {  
        if (arr[i] < min) {  
            min = arr[i];  
        }  
        if (arr[i] > max) {  
            max = arr[i];  
        }  
    }  
    // 根据最大值与最小值的差值决定数组的大小  
    int range = max - min + 1;// +1 是因为数组下标从 0 开始  
    int[] count = new int[range];  
    for (int i = 0; i < arr.length; i++) {  
        // 将数组中的元素放到对应的地方，统计arr数组中每个元素出现的次数  
        // 可以把count的0号下标看作存放min，最后一个下标存放max  
        count[arr[i]-min]++;  
    }  
    for (int i = 1; i < count.length; i++) {  
        // 因为光知道某个位置有多少个相同的元素并不能确定整个arr数组的顺序，所以把它们加起来作为前缀值，  
        // i 位置的值代表小于等于 ，min+i+1 的值有多少个，例如 count[2] = 2 代表小于等于 min+3 的值有2个  
        count[i] += count[i - 1];  
    }  
    int[] output = new int[arr.length];  
    for (int i = arr.length - 1; i >= 0; i--) {  
        int num = arr[i];  
        // 通过前缀值-1可以确定一个元素的位置（如果有相同的元素，就会放在这个元素最后的位置），这也是为什么要倒序填入output数组  
        int index = count[num-min] - 1;  
        output[index] = num;  
        // 确定一个元素的位置后将前缀值-1，下一次找到相同元素的位置就会在当前确定元素的位置的前面一个  
        count[num - min]--;  
    }  
  
    for (int i = 0; i < output.length; i++) {  
        arr[i] = output[i];  
    }  
}
```

```
  原数组 arr = [4, 2, 2, 8, 3, 3, 1]   min = 1, max = 8
      count = [1, 3, 5, 6, 6, 6, 6, 7] // 前缀和
 索引对应数字 = 1  2  3  4  5  6  7  8
    数组下标：  0  1  2  3  4  5  6  7

count[8] = 7 代表<=8的共有7个，count[arr[i] - min]表示arr[i]比最小值大多少个数组下标，也就是arr[i]对应在count中的位置，确定位置后用前缀值-1就可以得到该元素排序后的确切位置
```

>因为计数排序是按照倒序的方式确定元素的位置的，所以相同元素在排序后仍然具有原先的前后关系，因此计数排序是稳定的

>因为计数排序没有元素间的比较，所以实际耗时间的是关于数组的一些操作，它们的时间复杂度都是O(n)，所以计数排序的时间复杂度为O(n)，虽然它的时间复杂度比较低，但是计数排序只能对正整数排序，并且当最大值和最小值的差值过大时可能会浪费很多空间，所以计数排序只适合差值不大且元素大小分布较均匀的情况