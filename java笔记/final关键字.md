>final表示最终的,被它修饰的东西就不能再改变  
>final 类:此类无法再被继承  
>final 方法:此方法无法再被重写(仍可重载)  
>final 变量:此变量一旦被初次赋值后面就不能再赋值了  
>final 实例变量:必须在构造方法执行完毕前赋值,不允许使用默认值  
>final static 变量:此时该值被称作常量,不允许修改且被所有对象共享

**为什么普通变量可以赋一次值,实例变量就不行**

>因为普通的变量是局部变量,它不具备默认值,只能手动赋值,但是实例变量是具有默认值的,在构造方法执行完毕后系统会给它一个默认值,这个过程被看作一次赋值,所以后不能再修改了

>final 引用:此时该引用指向的地址不能在改变,但是指向的对象中的属性可以改变

```Java
final Person p = new Person("Jack",20);
p.setName("Mike");//可以,指向的地址不能改变与对象的属性无关
p = new Person();//这样不行,因为p会指向一个新的地址
```

**final修饰的方法是否会让调用变快?**

>有种说法认为final修饰的方法因为无法被调用,所以JVM不用去虚方法表中查找该方法所以会变快 
> 
>实际上并不是这样的,JVM有一种类层次分析手段,它会在运行时分析某个类的方法在所有已经加载的类中是否存在被重写的版本,如果没有就认为该方法是唯一的,不需要经过虚方法表来查找该方法,可以直接调用,就跟private和static修饰的方法一样,所以加上final并不会让调用更快  

>逻辑上好像是final方法调用更快,但是JVM的更新迭代让技术得到了完善,使这种差距不再依赖final的修饰
