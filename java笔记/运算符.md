# 一.逻辑运算符

>逻辑运算符要求两边的操作数都是布尔类型,并且最终运算结果也是布尔类型

```
& 逻辑与(并且)
| 逻辑或(或者)
^ 逻辑异或(相同false不同true),对整数的每个二进制位进行异或运算
int a = 10; //1010
int b = 5;  //0101
a^b = 1111 = 15

! 逻辑非

短路现象,前面有一个false,短路与就不会执行后面的内容
前面有一个true,短路或就不会执行后面的内容
&& 短路与
|| 短路或
```

# 二.按位运算符

>按位运算符的操作数必须是整数,否则会出现编译错误,因为float和double采用 IEEE 754 浮点数表示法，包括符号位、指数位和尾数位，而不是直接存储的二进制整数

```
<< 左移
>> 右移
>>> 无符号右移
& 按位与
| 按位或
^ 按位异或
~ 按位取反
```

## 1.左移

>将二进制数左移n位等于将数值乘以2<sup>n</sup>,左移后右边补上0,且不改变操作数的符号,但是会对溢出进行截断,需要注意的是,因为计算机底层是对补码进行操作的,所以这里的左移是对补码进行左移

**正数左移:**  

```
int a = 10;
原码:    00000000 00000000 00000000 00001010
反码:    00000000 00000000 00000000 00001010
补码:    00000000 00000000 00000000 00001010
左移2位: 00000000 00000000 00000000 00101000(补码) -> 40
```

**负数左移:**

```
int a = -100;
原码:    10000000 00000000 00000000 01100100
反码:    11111111 11111111 11111111 10011011
补码:    11111111 11111111 11111111 10011100
左移2位: 11111111 11111111 11111110 01110000(补码)
原码:    10000000 00000000 00000001 10010000 -> -400
```

## 2.右移

>右移n位等于除以2<sup>n</sup>,右移时符号位不变,正数左边补0,负数左边补1,会对溢出进行截断,对于0,右移仍然是0

**正数右移:**

```

```











