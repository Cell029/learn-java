# 1. 二叉树

>二叉树是一个递归的数据结构，每个节点最多有两个子节点，通常二叉树是一种排序二叉树，每个节点的值大于或者等于在它左子树节点上的值，小于或者等于在它右子树节点上的值

```java
public class BinaryTree {  
    static class TreeNode{  
        int value;  
        TreeNode left;  
        TreeNode right;  
        public TreeNode(int value) {  
            this.value = value;  
        }  
    }  
  
    TreeNode root;  
  
    // 插入入口  
    public void insert(int val) {  
        root = insert(root, val);  
    }  
  
    // 插入（构建二叉搜索树）  
    public TreeNode insert(TreeNode node, int value) {  
        // 递归找到空位置时创建节点  
        if (node == null) {  
            return new TreeNode(value);  
        }  
  
        if (value < node.value) {  
            // 当前节点的值小于根节点就向左递归  
            node.left = insert(node.left, value);  
        } else if (value > node.value) {  
            // 当前节点的值大于根节点就向右递归  
            node.right = insert(node.right, value);  
        }  
        return node;  
    }  
  
    // 查找元素  
    public boolean search(TreeNode node, int value) {  
        if (node == null) {  
            return false;  
        }  
        if (value == node.value) {  
            return true;  
        }  
        if (value < node.value) {  
            return search(node.left, value);  
        } else {  
            return search(node.right, value);  
        }  
    }  
  
    // 前序遍历：根 -> 左 -> 右  
    public void preOrder(TreeNode node) {  
        if (node == null) {  
            return;  
        }  
        System.out.print(node.value + " ");  
        preOrder(node.left);  
        preOrder(node.right);  
    }  
  
    // 中序遍历：左 -> 根 -> 右（BST 中序遍历有序）  
    public void inOrder(TreeNode node) {  
        if (node == null) {  
            return;  
        }  
        inOrder(node.left);  
        System.out.print(node.value + " ");  
        inOrder(node.right);  
    }  
  
    // 后序遍历：左 -> 右 -> 根  
    public void postOrder(TreeNode node) {  
        if (node == null) {  
            return;  
        }  
        postOrder(node.left);  
        postOrder(node.right);  
        System.out.print(node.value + " ");  
    }  
  
    // 求树的高度  
    public int getHeight(TreeNode node) {  
        if (node == null) {  
            return 0;  
        }  
        int leftHeight = getHeight(node.left);  
        int rightHeight = getHeight(node.right);  
        int maxHeight;  
        if (leftHeight > rightHeight) {  
            maxHeight = leftHeight;  
        } else {  
            maxHeight = rightHeight;  
        }  
        return maxHeight + 1;  
    }  
  
    // 节点个数  
    public int countNodes(TreeNode node) {  
        if (node == null) {  
            return 0;  
        }  
        int leftCount = countNodes(node.left);  
        int rightCount = countNodes(node.right);  
        return leftCount + rightCount + 1;  
    }  
}
```

```java
BinaryTree tree = new BinaryTree();  
  
// 插入元素构建二叉搜索树  
int[] nums = {7, 4, 9, 2, 5, 8, 10};  
for (int num : nums) {  
    tree.insert(num);  
}  
  
System.out.print("前序遍历: ");  
tree.preOrder(tree.root); // 前序遍历: 7 4 2 5 9 8 10   
System.out.println();  
  
System.out.print("中序遍历: ");  
tree.inOrder(tree.root); // 中序遍历: 2 4 5 7 8 9 10 
System.out.println();  
  
System.out.print("后序遍历: ");  
tree.postOrder(tree.root); // 后序遍历: 2 5 4 8 10 9 7 
System.out.println();  
  
System.out.println("树的高度: " + tree.getHeight(tree.root)); // 树的高度: 3 
System.out.println("节点总数: " + tree.countNodes(tree.root)); // 节点总数: 7 
System.out.println("是否包含 5: " + tree.search(tree.root, 5)); // 是否包含 5: true 
System.out.println("是否包含 15: " + tree.search(tree.root, 15)); // 是否包含15:false
```

>因为每个节点的左节点小，右节点大，所以中序遍历出来的顺序正好就是所有元素排序后的顺序

****
# 2. 平衡二叉树

>平衡二叉树是一种特殊的二叉排序树，其中每一个节点的左子树和右子树的高度差至多等于1，它是一种高度平衡的二叉排序树，高度平衡就是要么它是一颗空树，要么它的左子树和右子树都是平衡二叉树，且左子树和右子树的深度只差的绝对值绝对不超过1

>将二叉树上节点的左子树深度减去右子树深度的值称为平衡因子BF，则平衡二叉树上所有节点的平衡因子只可能是1，-1，0

>最小不平衡子树：距离插入节点最近的，且平衡因子的绝对值大于1的节点为根的子树，称为最小不平衡子树

**实现原理**

>平衡二叉树构建的基本思想就是在构建二叉排序树的过程中，每当插入一个节点时，先检查是否因插入而破坏了树的平衡性，如果是，就找出最小不平衡树，并且在保持二叉排序树特性的前提下，调整最小不平衡子树中各节点之间的链接关系，进行相应的旋转，使之成为新的平衡子树

**旋转操作**

- 右单旋：插入在左子树的左侧导致不平衡
>当前节点的左孩子会作为新树的根节点，而当前节点则作为新树的根节点的右孩子
- 左单旋：插入在右子树的右侧导致不平衡
>当前节点的右子树会作为新树的根节点，而当前节点则作为新树的根节点的左子树
- 左右旋：插入在左子树的右侧导致不平衡
- 右左旋：插入在右子树的左侧导致不平衡

>如果新的树根原来有左子树，那这个原来的左子树就会作为当前节点（就根节点）的右子树

**LL型右旋**

```
        y
       /
      x
     / \
   T1   T2

```

```
      x
     / \
   T1   y
       / \
     T2   ?

```

>右旋后 y 会成为 x 的右孩子， T1 仍然是 x 的左孩子，不过 T2 会成为 y 的左孩子，为什么呢？因为二叉排序树的特性， x < T2 < y ，所以右旋后没地方可以去的 T2 只能成为 y 的左孩子

**RR型左旋**

```
  z
   \
    y
     \
      x

```

```
    y
   / \
  z   x
```

**LR型先左后右**

```
      z
     /
   y 
     \
       x
```

先对左子树进行左旋拉成 LL 型

```
      z
     /
    x
   /
  y
```

右旋

```
    x
   / \
  y   z
```

**RL型先右后左**

```
  z
   \
     y
   /
 x

```

先对右子树右旋拉成RR型

```
  z
   \
    x
     \
      y

```

左旋

```
    x
   / \
  z   y
```

