# 1. 二叉树

>二叉树是一个递归的数据结构，每个节点最多有两个子节点，通常二叉树是一种排序二叉树，每个节点的值大于或者等于在它左子树节点上的值，小于或者等于在它右子树节点上的值

```java
public class BinaryTree {  
    static class TreeNode{  
        int value;  
        TreeNode left;  
        TreeNode right;  
        public TreeNode(int value) {  
            this.value = value;  
        }  
    }  
  
    TreeNode root;  
  
    // 插入入口  
    public void insert(int val) {  
        root = insert(root, val);  
    }  
  
    // 插入（构建二叉搜索树）  
    public TreeNode insert(TreeNode node, int value) {  
        // 递归找到空位置时创建节点  
        if (node == null) {  
            return new TreeNode(value);  
        }  
  
        if (value < node.value) {  
            // 当前节点的值小于根节点就向左递归  
            node.left = insert(node.left, value);  
        } else if (value > node.value) {  
            // 当前节点的值大于根节点就向右递归  
            node.right = insert(node.right, value);  
        }  
        return node;  
    }  
  
    // 查找元素  
    public boolean search(TreeNode node, int value) {  
        if (node == null) {  
            return false;  
        }  
        if (value == node.value) {  
            return true;  
        }  
        if (value < node.value) {  
            return search(node.left, value);  
        } else {  
            return search(node.right, value);  
        }  
    }  
  
    // 前序遍历：根 -> 左 -> 右  
    public void preOrder(TreeNode node) {  
        if (node == null) {  
            return;  
        }  
        System.out.print(node.value + " ");  
        preOrder(node.left);  
        preOrder(node.right);  
    }  
  
    // 中序遍历：左 -> 根 -> 右（BST 中序遍历有序）  
    public void inOrder(TreeNode node) {  
        if (node == null) {  
            return;  
        }  
        inOrder(node.left);  
        System.out.print(node.value + " ");  
        inOrder(node.right);  
    }  
  
    // 后序遍历：左 -> 右 -> 根  
    public void postOrder(TreeNode node) {  
        if (node == null) {  
            return;  
        }  
        postOrder(node.left);  
        postOrder(node.right);  
        System.out.print(node.value + " ");  
    }  
  
    // 求树的高度  
    public int getHeight(TreeNode node) {  
        if (node == null) {  
            return 0;  
        }  
        int leftHeight = getHeight(node.left);  
        int rightHeight = getHeight(node.right);  
        int maxHeight;  
        if (leftHeight > rightHeight) {  
            maxHeight = leftHeight;  
        } else {  
            maxHeight = rightHeight;  
        }  
        return maxHeight + 1;  
    }  
  
    // 节点个数  
    public int countNodes(TreeNode node) {  
        if (node == null) {  
            return 0;  
        }  
        int leftCount = countNodes(node.left);  
        int rightCount = countNodes(node.right);  
        return leftCount + rightCount + 1;  
    }  
}
```

```java
BinaryTree tree = new BinaryTree();  
  
// 插入元素构建二叉搜索树  
int[] nums = {7, 4, 9, 2, 5, 8, 10};  
for (int num : nums) {  
    tree.insert(num);  
}  
  
System.out.print("前序遍历: ");  
tree.preOrder(tree.root); // 前序遍历: 7 4 2 5 9 8 10   
System.out.println();  
  
System.out.print("中序遍历: ");  
tree.inOrder(tree.root); // 中序遍历: 2 4 5 7 8 9 10 
System.out.println();  
  
System.out.print("后序遍历: ");  
tree.postOrder(tree.root); // 后序遍历: 2 5 4 8 10 9 7 
System.out.println();  
  
System.out.println("树的高度: " + tree.getHeight(tree.root)); // 树的高度: 3 
System.out.println("节点总数: " + tree.countNodes(tree.root)); // 节点总数: 7 
System.out.println("是否包含 5: " + tree.search(tree.root, 5)); // 是否包含 5: true 
System.out.println("是否包含 15: " + tree.search(tree.root, 15)); // 是否包含15:false
```

>因为每个节点的左节点小，右节点大，所以中序遍历出来的顺序正好就是所有元素排序后的顺序

****
# 2. 平衡二叉树

