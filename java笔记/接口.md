
>接口是Java中一种规范,它定义了一组抽象方法和常量,用来描述实现这个接口的类应该具哪些属性和行为,接口和类一样,也是一种引用数据类型

****
# 一.接口的定义

```Java
public interface MyInterface {  
    int CONST = 100;//常量  
    void methodA();//方法  
}
```

**(1) 接口中的默认修饰符**  

>接口中的所有变量都默认被`public static final`修饰(一般被编译器隐含起来),所以接口中的所有变量都是常量,不能被继承/修改,并且不能使用其他修饰符对其进行修饰,但`static`和`final`是可以的,不过依旧默认会补充成`public static final`
>
>因为接口的本质是只定义行为,不存储状态,所以不应该包含可变的字段
>
>在Java8以前,接口中的方法默认`public abstract`修饰,不能使用其他修饰符

****

**(2) 接口不允许实例化**  

>和抽象类不能实例化的原因一致,根本原因其实并不是因为没有构造器,而是因为它的方法只声明,不实现
>
>**接口为什么没有构造器?** 
>
>构造器是用来初始化对象的,而接口中只有常量,因此就没有实例变量可以被初始化的,那么就没有使用构造器的理由了

****

**(3) 接口可作为标记**

>接口里面可以什么都不定义,没有变量和方法,通常用来给类做一个标记,通过`instanceof`来判断类是否实现了某个接口,然后手动执行相应的逻辑,并不是JVM自动执行相应逻辑

```Java
public interface Serializable {}

//Test实现了一个空的Serializable接口
class Test implements Serializable{
	main{
		//判断这个类要实现哪种功能,然后进行相关的操作
		if (Test instanceof Serializable) {
		    //执行序列化操作
		}
	}
}
```

****

**(4) Java8之后接口中允许出现默认方法和静态方法**  

>因为接口中默认的方法是抽象的,所以实现类必须重写这个接口中的所有方法,这就导致当接口中出现新增或者删除方法时,所有实现类都得修改,这就太麻烦了,况且有些方法也许是实现类不需要的,但实现类也无法拒绝,因此引入了新机制,让 接口中允许使用`default`和`static`  
>
>`default`方法的出现可以实现接口向后兼容,在不破坏已有的实现类的情况下新增代码,实现类可以不重写这个方法,那么实现类便会继承这个方法,直接通过 对象.方法名 调用  
>所以接口的实现也可以看作是一种另类的继承(只作为口头理解,不能当作正确概念)

```Java
public interface MyInterface {  
    int CONST = 100;//常量  
    void methodA();//方法  
  
    default void defaultMethod() {  
        System.out.println("defaultMethod is called");  
    }  
}

public class MyInterfaceImpl implements MyInterface {  
    @Override  
    public void methodA() {  
        System.out.println("override methodA");  
    }  
}

MyInterfaceImpl myInterfaceImpl = new MyInterfaceImpl();  
myInterfaceImpl.methodA();//override methodA
myInterfaceImpl.defaultMethod();//defaultMethod is called
```


>`static`方法可以给接口提供一种定义通用工具方法的能力,有了这个方法之后,就可以把接口当作工具类使用,一般的工具类都存在构造器并通过使用`private`来禁用构造器,而接口不存在,虽然调用静态方法会加载类,但都不会创建对象,所以接口和传统工具类并没有实质性的内存差异,它们都只在方法区中保存静态信息,关键在于接口它天生的没有构造器,在使用时更清晰,安全

![](images/接口/file-20250411211211.png)

****

**(5) Java9之后接口中允许使用`private`修饰方法**

>这一特性的出现,让接口作为新工具类的能力得到了进一步的提升,由于接口中的方法默认是抽象的,所以是无法直接使用的,当我需要写一个工具类时,可能会使用很多代码,这里面肯定存在可以复用的代码,如果没有`private`来修饰方法,那么这些方法就可以被实现类重写或者调用,这明显破坏了Java程序的封装性,它作为接口的复用代码也失去了意义,所以复用代码应该被私有化,无法被实现类继承

****

# 二.接口的实现

**(1) 多接口的实现**

>一个类虽然不能继承多个父类,但可以实现多个接口

# 三.接口的作用


# 四.抽象类和接口类