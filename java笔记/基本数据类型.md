
| 数据类型        | 占用字节数 | 取值范围                              | 具体取值范围                                                 | 默认值      |
| ----------- | ----- | --------------------------------- | ------------------------------------------------------ | -------- |
| **byte**    | 1     | \( -2^7 \) ~ \( 2^7-1 \)          | -128 ~ 127                                             | 0        |
| **short**   | 2     | \( -2^{15} \) ~ \( 2^{15}-1 \)    | -32,768 ~ 32,767                                       | 0        |
| **int**     | 4     | \( -2^{31} \) ~ \( 2^{31}-1 \)    | -2,147,483,648 ~ 2,147,483,647                         | 0        |
| **long**    | 8     | \( -2^{63} \) ~ \( 2^{63}-1 \)    | -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807 | 0L       |
| **float**   | 4     | 1.4E-45 ~ 3.4028235E38            | 1.4E-45 ~ 3.4028235E38                                 | 0.0f     |
| **double**  | 8     | 4.9E-324 ~ 1.7976931348623157E308 | 4.9E-324 ~ 1.7976931348623157E308                      | 0.0d     |
| **boolean** | 1     | true / false                      | true / false                                           | false    |
| **char**    | 2     | \( 0 \) ~ \( 2^{16}-1 \)          | 0 ~ 65,535                                             | '\u0000' |

==byte<short<int<long<float<double==

所有的引用数据类型.默认值是:null

# 一.整数型

>Java中任何一个整数型变量都会默认被当作int类型处理,例如 `int a = 100`
>
>因为Java中,等号右边先执行,所以100会先被存入一个临时变量,不管怎么样,都给他四个字节的存储空间,因为a是int类型,刚好四个字节,不存在类型转换,但是如果是`long a = 100`,就是把四个字节的内容放到八个字节中,小容量自动赋值给大容量,这就叫自动类型转换

>但是,如果在整数型后面加上了L,Java就会把他识别为long类型,直接给他8个字节的空间,而不是默认类型,那么`long a = 100`就不存在类型转换

>如果这个值超出了int类型的范围,并且后面没有加上L,那么就会报错,因为等号右边先执行,Java把他默认为了int类型,可是这个数超过了范围,那么用int就无法表示,就只能报错了,但并不是long存不下

![](images/基本数据类型/file-20250403204432.png)

![](images/基本数据类型/file-20250403204452.png)

>两个int类型的数据进行运算后,仍然是int类型  
>==多种类型的数据运算时,先转换成最大的再运算==

![](images/基本数据类型/file-20250403211210.png)

>byte 和 short运算时,会各自转换成int类型再运算  
>byte+byte -> int  
>short+short -> int

![](images/基本数据类型/file-20250403212031.png)

# 二.浮点型

>float单精度,精度为7位小数  
>double双精度,精度为15位小数

>浮点型字面量默认被当作double类型处理,想要用float类型就要加上F

>浮点型可以用科学计数法表示:`double a = 1.23E10`=1.23x10<sup>10</sup>, 123E-2=123x10<sup>-2</sup>=1.23

**==为什么float的容量比long还要大?==**

>虽然float只有32位,但是这些二进制位表示的东西和long的不同,long的64位全部用来存放二进制,而float的第一位表示正负,2~9位存的是指数位,剩下的23位存位数位,只有这23位是和long一样,虽然放的少,但它以指数级增长,范围肯定更大

>浮点型数据参与运算得出的结果不要与其他值用`==`比较,因为计算机底层存储的浮点型是它的近似值,通常使用极小误差来判断相等

![](images/基本数据类型/file-20250403220327.png)

# 三.char

>char类型统一采用Unicode编码,且默认值是\u0000,虽然char和short一样只占两个字节,但是char表示的范围是0~65535,没有负数

>char声明的变量只能放一个字符,并且不能放空字符(也就是里面什么都不写,并不是打一个空格)

>声明char变量时,如果是一个整数型字面量并且没有超过char的范围,那么这个字面量可以当作ASCII码值来处理

![](images/基本数据类型/file-20250404164343.png)

>也可以使用Unicode码声明char,\u后面跟的是十六进制,并且要对应Unicode码

![](images/基本数据类型/file-20250404164541.png)

**转义字符**

>因为转义字符比较特殊,所以用char的时候可以拿某些字母和转义字符搭配使用,并不会造成char报错

```
\t:制表符,等于tab键
\n:换行符
\":表示双引号(")
\':表示单引号(')
\\:表示反斜杠(\)
```

**char的运算**

>运算时根据ASCII表将字符解码成二进制,然后Java将这个二进制转换成int类型的数据再运算,如果把算好的值再赋值给char的话,就会把这个值当作ASCII来编码

![](images/基本数据类型/file-20250404170444.png)
# 四.boolean

>boolean只有两个值:true和false,Java中不能直接当作1和0来进行运算,这是boolean和以上类型的最大区别

![](images/基本数据类型/file-20250404171108.png)
# 五.字符编码

>人为规定文字与二进制的转换关系

**ASCII编码**

>用8位二进制进行编码(一个字节)，用于表示控制字符、英文字符、数字字符。因为使用8位二进制编码，所以ASCII编码只能表示256个字符,编号范围为0~255,需要注意的是,这些都是字符,不是int类型  
>常用的:  
>a 对应 ASCII中的 97(b是98...)  
>A 对应 ASCII中的 65(B是66...)  
>0 对应 ASCII中的 48(1是49...)

>'a' -> ASCII编码 -> 97 -> 0110 0001  
>0110 0001 ->ASCII解码 -> 'a'

**Unicode编码**

>Java采用的编码,可以表示所有的语言,采用十六进制,占用两个字节或者四个字节

**utf-8编码**

>基于Unicode编码的可变长度字符编码,使用1~4个字节表示一个字符,是web开发常用的,字母1个字节,汉字3个字节

**gbk编码**

>针对中文设计的编码,用2个字节表示一个汉字

**乱码问题**

>当编码和解码时使用的码表不同,就会产生乱码

# 六.数据类型转换

>Java要求等号左边和等号右边的类型要一致，如果不一致，就需要进行数据类型转换,Java中不同的类型之间，在满足数据兼容的条件下可以实现转换.

**自动类型转换**

>容量小的类型自动转换为容量大的数据类型

>byte->short,byte->int,byte->long...以此类推,在这个转换过程,编译不会报错,他会自动把小的类型转换成大的类型

>对于byte,short,char  
>给他们赋值时可以直接写int类型,尽管他们比int小,但是系统会自动给他们转换,也就是只要不超过他们的取值范围,都可以自动转换


**强制类型转换**

>容量大的数据类型转换为容量小的数据类型

```java
long a = 100L;  
int b = (int)a;
```

>byte,short,char进行混合运算时,需要把最总结果转换成int或者long,浮点型同理,不过这也可以看做是java的自动转型

![](images/基本数据类型/file-20250404175600.png)

>强制类型转换可能会导致数据丢失或者精度降低,因为原始的数据可能比强转的类型能够储存的容量大,多余的部分自然会丢失,例如double->int,一定会丢失小数的部分

```
int k = 128;
k: 0000 0000 0000 0000 0000 0000 1000 0000
short j = (short)k;
j:                     0000 0000 1000 0000
这里就丢失了前面的两个字节,因为当前的128并没有超过short类型的范围,所以并没有造成实质的数据丢失
```

>看下例,将int类型强转成byte类型,会丢失三个字节的数据,又因为这是有符号的数据,所以最高位是符号位,128就变成了-128

```java
int k = 128;
byte b = (byte)k;
sout(b);//-128
```

```
int k = 128;
k: 0000 0000 0000 0000 0000 0000 1000 0000 = 128
byte b = (byte)k;
j:                               1000 0000 = -128
```

>浮点型强转成整数型,舍弃的是二进制的尾数部分

![](images/基本数据类型/file-20250404182649.png)

>