
>根据元素的进制确定需要多少个链表，然后从低位或者高位开始一位一位的排序，直到每一位都排完

![](images/基数排序/aa641ab4977c61d5f6eb16a4ffbd3635_720.png)

```java
public static void main(String[] args) {  
    int[] arr = {170, 45, 75, 90, 802, 24, 2, 66};  
    int max = arr[0];  
    for (int num : arr) {  
        if (num > max) {  
            max = num;  
        }  
    }  
  
    for (int digit = 1; max / digit > 0; digit *= 10) {  
        // 根据最大值来确定每个元素最多需要比较几次位数  
        radixSort(arr, digit);  
    }  
  
    System.out.println(Arrays.toString(arr));  
}  
  
public static void radixSort(int[] arr, int digit) {  
    List<List<Integer>> buckets = new ArrayList<>();  
    for (int i = 0; i < 10; i++) {  
        buckets.add(new LinkedList<>());  
    }  
    for (int i = 0; i < arr.length; i++) {  
        // 根据当前位数的数组是多少放入对应数字的例表中  
        buckets.get((arr[i] / digit) % 10).add(arr[i]);  
    }  
    int index = 0;  
    for (int i = 0; i < 10; i++) {  
        for (int j = 0; j < buckets.get(i).size(); j++) {  
            // 按照顺序把列表中的所有元素取出来，并更新数组  
            arr[index] = buckets.get(i).get(j);  
            index++;  
        }  
    }  
}
```

>因为基数排序有种队列的思想，先进先出，所以相同的元素经过排序后仍然具有原先的前后关系

>因为基数排序没有元素对比的环节，所以它只有对数组进行循环操作时才会耗时，故时间复杂度为O(n)

>因为需要对位数进行划分，并且把链表划分成0~9，所以基数排序处理浮点数与负数是比较困难的


