
>注解本质上就是代码中的“标记”或“说明”，这些信息可以被编译器、开发工具、运行时环境读取并处理。

# 1. 自定义注解

```java
public @interface 注解名 {
    // 属性定义
    数据类型 属性名() default 默认值;
}
```

>使用 @interface 自定义注解时，自动继承了 java.lang.annotation.Annotation 接口，JVM 会自动将其编译成接口；在定义注解时，不能继承其他的注解或接口；@interface 用来声明一个注解，其中的每一个方法实际上是声明了一个配置参数，方法的名称就是参数的名称，返回值类型就是参数的类型，并且可以通过 default 来声明参数的默认值。

## 1.1 自定义注解的属性

| 类型类别          | 示例                                                                   |
| ------------- | -------------------------------------------------------------------- |
| 所有基本数据类型      | `int`, `float`, `double`, `boolean`, `long`, `short`, `byte`, `char` |
| `String` 类型   | 如：`String name()`                                                    |
| `Class<?>` 类型 | 如：`Class clazz()`                                                    |
| 枚举类型（`enum`）  | 如：`MyEnum type()`                                                    |
| 注解类型（嵌套注解）    | 如：`OtherAnnotation config()`                                         |
| 上述类型的数组形式     | 如：`String[] tags()`、`int[] values()`                                 |

>每个属性可以使用 `default` 关键字指定默认值，如果不给某个属性设置默认值，那么使用注解时必须显式为它赋值，否则系统会报错。
>
>注解不能有 null 值，也不支持 Map、List 。
>
>当某个属性是数组时，需要这样写 `@MyAnnotation(tags = {"A", "B", "C"})` ，只有一个元素时则可以省略大括号，`@MyAnnotation(tags = "A")` 

```java
public enum HttpMethod {  
    GET, POST, PUT, DELETE  
}

// 定义嵌套注解数组
public @interface Param {  
    String name();  
    Class<?> type();  
}

@Retention(RetentionPolicy.RUNTIME) // 告诉编译器 & JVM：这个注解在运行时也要保留，这样才可以在运行时通过反射拿到它  
@Target(ElementType.METHOD) // 让自定义的注解只能加在方法上  
public @interface MyAnnotation {  
    String author();                          // 字符串类型  
    int version() default 1;                  // 基本类型 + 默认值  
    boolean deprecated() default false;       // boolean 类型  
    HttpMethod method();                      // 枚举类型  
    Class<?> returnType();                    // Class 类型  
    Param[] params() default {};              // 嵌套注解数组  
}
```

>在方法上使用自定义的注解

```java
public class UserController {  
    @MyAnnotation(  
            author = "Cell",  
            version = 2,  
            deprecated = false,  
            method = HttpMethod.POST,  
            returnType = String.class,  
            params = {  
                    @Param(name = "userId", type = Integer.class),  
                    @Param(name = "userName", type = String.class)  
            }    )  
    public String createUser(int userId, String userName) {  
        return "User Created";  
    }  
}
```

****
## 1.2 通过反射机制获取注解信息

```java
public static void main(String[] args) throws Exception {  
    // 获取 UserController 类中名为 createUser 的方法，参数类型是 int 和 String    
    Method method = UserController.class.getMethod("createUser", int.class, String.class);  
    // 判断这个方法上是否有 @MyAnnotation 注解  
    if (method.isAnnotationPresent(MyAnnotation.class)) {  
        // 获取注解实例  
        MyAnnotation myAnnotation = method.getAnnotation(MyAnnotation.class);  
        System.out.println("作者: " + myAnnotation.author());  
        System.out.println("版本: " + myAnnotation.version());  
        System.out.println("方法类型: " + myAnnotation.method());  
        System.out.println("返回类型: " + myAnnotation.returnType().getSimpleName());  
  
        for (Param p : myAnnotation.params()) {  
            System.out.println("参数: " + p.name() + " - 类型: " + p.type().getSimpleName());  
        }  
    }  
}
```

****
# 2. 元注解

