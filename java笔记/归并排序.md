
### 1.分治法

>一种解决复杂问题的算法思想，将一个大问题分解成多个小问题，将这些小问题递归地解决后再将它们的结果合并，也就是 分解 → 解决 → 合并

```
归并排序数组：[8, 3, 5, 2, 9, 1, 7, 4]

分解：
[8, 3, 5, 2, 9, 1, 7, 4]
=> [8, 3, 5, 2] | [9, 1, 7, 4]
=> [8, 3] | [5, 2] | [9, 1] | [7, 4]
=> ...

解决：
递归直到每个子数组只有一个元素

合并：
[3, 8], [2, 5], ...
最终合并为：[1, 2, 3, 4, 5, 7, 8, 9]
```

>所以快速排序也可以看作是一种分治法

### 2.归并排序

>把数组不断地“二分”直到无法再分，然后将这些“有序的小数组”逐步合并成“有序的大数组”

```
原始数组：[8, 3, 5, 2, 9, 1, 7, 4]

分解：
[8, 3, 5, 2] | [9, 1, 7, 4]
[8, 3] [5, 2] | [9, 1] [7, 4]
[8] [3] [5] [2] | [9] [1] [7] [4]

合并：
[3, 8] [2, 5] | [1, 9] [4, 7]
[2, 3, 5, 8] | [1, 4, 7, 9]
→ [1, 2, 3, 4, 5, 7, 8, 9]
```

>从两个相邻的有序子数组中选择当前最小的元素放入结果数组中，当一个子数组中元素放完了，另一个子数组可以直接接上

```java
public static void main(String[] args) {  
    int[] arr = {8, 3, 5, 2, 9, 1, 7, 4};  
    mergeSort(arr, 0, arr.length - 1);  
    System.out.println(Arrays.toString(arr));  
}  
  
public static void mergeSort(int[] arr, int left, int right) {  
    if (left >= right) return;  
    int mid = left + (right - left) / 2;  
    mergeSort(arr, left, mid);  
    mergeSort(arr, mid + 1, right);  
    merge(arr, left, mid, right);  
}  
  
public static void merge(int[] arr, int left, int mid, int right) {  
    int[] temp = new int[right - left + 1];  
    int i = left, j = mid + 1;  
    int k = 0;  
    while (i <= mid && j <= right) {  
        if (arr[i] <= arr[j]) {  
            temp[k] = arr[i];  
            k++;  
            i++;  
        } else {  
            temp[k] = arr[j];  
            k++;  
            j++;  
        }  
    }  
    while (i <= mid) {  
        temp[k] = arr[i];  
        k++;  
        i++;  
    }  
    while (j <= right) {  
        temp[k] = arr[j];  
        k++;  
        j++;  
    }  
    for (int t = 0; t < temp.length; t++) {  
        arr[left + t] = temp[t];  
    }  
}
```
