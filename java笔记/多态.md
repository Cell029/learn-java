
>多态就是同一个接口/方法名,可以有不同的实现

# 一.编译时的多态

>这个也叫静态多态,在编译阶段确定,叫做方法重载

# 二.运行时的多态

>这个也叫动态多态,在运行时确定

## 1.方法重写(方法覆盖)

>这个容易跟方法重载搞混,方法重写注重的是子类重写父类的方法,在这期间不改变方法名和方法的参数列表(这就是和方法重载的最大区别)

```Java
class Animal {
    public void sound() {
        System.out.println("动物发出声音");
    }
}

class Dog extends Animal {
    @Override
    public void sound() {
        System.out.println("狗叫：汪汪！");
    }
}

class Cat extends Animal {
    @Override
    public void sound() {
        System.out.println("猫叫：喵喵！");
    }
}

main() {
Animal a1 = new Dog();//父类引用指向子类对象
Animal a2 = new Cat();

a1.sound();//狗叫：汪汪！
a2.sound();//猫叫：喵喵！
}
```

>当父类的方法无法满足子类的业务的时候就可以方法重写,最常用的就是toString的重写

```Java
@Override  
public String toString() {  
    return "Student{" +  
            "name='" + name + '\'' +  
            ", age=" + age +  
            ", course=" + course +  
            '}';  
}
```

**Override注解**

>用来标注方法为重写方法,如果报错证明它不是重写方法,因为它是起一种检查的作用,类似于javac,所以它在编译阶段起作用


**返回值类型**

>子类重写方法时,可以把父类的返回值类型修改成返回值类型的子类,但是必须是引用型的返回值类型才行

>访问权限可以变高,但是不能变低,public->protected->默认->private,抛出异常不能变多,可以变少


**JVM怎么实现方法重写的?**

>在程序运行时,JVM会根据实际调用的对象来确定调用哪个方法,如果子类重写了,那就调用子类的

>所以说方法重写是需要依赖对象的,所以它才只能在运行时起作用,因为对象是在这个时候才产生的,而方法重载依赖的变量的声明类型,跟对象的实际类型没关系,这就牵扯到了

