
>多态就是同一个接口/方法名,可以有不同的实现

# 一.编译时的多态

>这个也叫静态多态,在编译阶段确定,叫做方法重载

# 二.运行时的多态

>这个也叫动态多态,在运行时确定

## 1.方法重写(方法覆盖)

>这个容易跟方法重载搞混,方法重写注重的是子类重写父类的方法,在这期间不改变方法名和方法的参数列表(这就是和方法重载的最大区别)

```Java
class Animal {
    public void sound() {
        System.out.println("动物发出声音");
    }
}

class Dog extends Animal {
    @Override
    public void sound() {
        System.out.println("狗叫：汪汪！");
    }
}

class Cat extends Animal {
    @Override
    public void sound() {
        System.out.println("猫叫：喵喵！");
    }
}

main() {
Animal a1 = new Dog();//父类引用指向子类对象
Animal a2 = new Cat();

a1.sound();//狗叫：汪汪！
a2.sound();//猫叫：喵喵！
}
```

>当父类的方法无法满足子类的业务的时候就可以方法重写,最常用的就是toString的重写

```Java
@Override  
public String toString() {  
    return "Student{" +  
            "name='" + name + '\'' +  
            ", age=" + age +  
            ", course=" + course +  
            '}';  
}
```

**Override注解**

>用来标注方法为重写方法,如果报错证明它不是重写方法,因为它是起一种检查的作用,类似于javac,所以它在编译阶段起作用


**返回值类型**

>子类重写方法时,可以把父类的返回值类型修改成返回值类型的子类,但是必须是引用型的返回值类型才行

>访问权限可以变高,但是不能变低,public->protected->默认->private,抛出异常不能变多,可以变少


**JVM怎么实现方法重写的?**

>在程序运行时,JVM会根据实际调用的对象来确定调用哪个方法,如果子类重写了,那就调用子类的

>所以说方法重写是需要依赖对象的,所以它才只能在运行时起作用,因为对象是在这个时候才产生的,而方法重载依赖的变量的声明类型,跟对象的实际类型没关系,这就牵扯到了父类引用指向子类对象


## 2.父类引用指向子类对象

**向上转型**

>子类->父类(可看作自动类型转换),但是一定要具有继承关系

```
Animal animal = new Cat();小->大
animal.move();
```

>在编译阶段,编译器只知道animal的类型是Animal类型,所以编译时就回去Animal类中找move方法,找到后就绑定该方法的符号引用

>运行阶段,Cat对象就被创建出来了,因为实例方法的使用必须依赖对象,所以move()的行为一定是Cat对象发生的,虽然编译器只知道animal的类型是Animal,但JVM会检查animal的实际指向的是Cat,JVM就会从Cat的方法表中查找是否重写了,没有重写就向上查找

>这里需要补充一个知识点:Java的多态有个机制,那就是只要这个方法是虚方法(没有private,static,final修饰),JVM永远会根据对象的真实类型来找方法表,编译器的move方法的字符引用只是用来告诉JVM我要用的是move方法,其余的JVM会自己搞定

**搞半天JVM还是根据实际对象找方法表,为什么还要弄个向上转型**

>不是JVM多此一举要进行向上转型,是程序员手动进行向上转型的,这就涉及到多态的优势了

**重写的目的就是为了改写父类行为,为什么还要向上转型?**

>这里存在一个调用逻辑的问题,如果不适用向上转型,那么每次使用某个对象的某个方法都需要去创建这个对象然后调用这个对象的方法,虽然向上转型后也需要创建不同的对象,但是每个对象的引用类型是统一的,再根据编译时的字符引用的特性,就可以直接使用这个向上转型的类里面的方法,哪怕它在底层真正调用的是具体对象的重写的方法,不管创建多少个对象,调用的方法始终是同一个方法,只不过传入的引用是不同的而已

>这也是为什么Animal类型的引用去调用子类自己写的方法会报错的原因

```Java
Animal a1 = new Dog();//向上转型
Animal a2 = new Bird();
Animal a3 = new Cat();

makeAnimalMove(a1);//看似调用了很多方法,实际上每次调用的是同一个方法
makeAnimalMove(a2);
makeAnimalMove(a3);

void makeAnimalMove(Animal a) {
    a.move();//自动根据实际对象调用Dog/Bird/Cat中重写的方法（多态）
}
```

>所以说向上转型的使用更像是写一套属于自己的模板(大概吧..),让后续的代码可以使用这个模板,不用新增某些逻辑,感觉这又扯到了封装的概念,把对象的使用逻辑给封装了一遍

>所以多态就是编译时一种形态,运行时另一种形态

**向下转型**

>父类->子类(可看作强制类型转换),当父类调用子类中特有的方法时才考虑向下转型

```Java
//因为Animal和Bird之间存在继承关系,所以这个编译可以通过
//但是运行时堆中的真实对象是Cat,Cat和Bird没有继承关系,所以Cat无法强转成Bird,所以会报错
//ClassCastException
Animal animal = new Cat();
Bird bird = (Bird)animal;
```

>向下转型非常容易报错,所以在转型前通常要判断一下它是否属于哪个类型

**instanceof**

```
instanceof是Boolean类型,用于判断某个类是否属于某个类型
例如:
	animal instanceof Cat
	true:animal是Cat类型
	false:animal不是Cat类型
```


# 三.开闭原则(Open-Closed Principle,OCP)

>一个软件实体应该对扩展开放,对修改关闭,即在不修改原有代码的基础上通过添加新的代码来扩展功能


<a>没写完,明天继续补充</a>

