
## 1. String类

>String 类代表字符串，Java 程序中的所有字符串字面值（如 "abc" ）都作为此类的实例实现，字符串是常量，它们的值在创建之后不能更改

****
## 2. String的不可变性

>`String` 对象一旦被创建，其内容是不可更改的，就算修改了字符串的值，实际上也是创建了一个新的对象，原对象保持不变，而接收变量的那个引用指向新的对象

![](images/字符串/file-20250422093106.png)

>String类是被final修饰的，它不允许被继承，其次`String` 类内部定义了一个用来存储字符串内容的字节数组（在 Java 9 之后为 `byte[]`，在此之前为 `char[]`），该数组被 `private` 和 `final` 修饰，`final` 关键字保证了数组引用在对象创建后不可更改，也就是说它始终指向同一个数组，无法重新赋值，`private` 关键字限制了对数组的直接访问，防止外部程序绕过方法直接修改内容，所以对字符串进行修改操作（如拼接、截取等）时，实际上都会创建一个新的 `String` 对象，而不是在原对象上进行更改

****
## 3. 字符串常量池

> `String` 是不可变的对象，如果 JVM 每次都创建一个新的 `String` 对象，那么相同的就会在内存中存在两份，浪费空间，当JVM 将所有的字符串字面量放入字符串常量池中后，如果已经存在相同的就直接返回已有引用避免重复创建具有相同内容的对象

>如果是字符串字面量编译期就直接放入常量池，或者使用 `intern()` 方法在运行期将堆中的字符串手动加入常量池，但是所有的相同字符串字面量只会在常量池中存一份

****
## 4. 创建字符串的两种方式

### 4.1 字面量方式创建

```java
String str1 = "hello";
```

>Java 提供了一个字符串常量池（String Constant Pool），当使用双引号创建字符串时 JVM 会先在字符串常量池中查找是否已经存在相同内容的字符串对象，如果存在就直接返回引用，不存在就创建一个新的对象放进去

```java
String str1 = "abc";
String str2 = "abc";
System.out.println(str1 == str2); // true，两个变量引用的是常量池中的同一个对象
```

****
### 4.2 new 方式创建

```java
String str3 = new String("hello");
```

>这种方式会在堆内存中创建一个新的字符串对象，即使常量池中已经有相同内容的字符串，`new` 也会强制创建一个新的实例，这个 `new` 出来的字符串不会放到常量池中，而是放在堆中，  
>如果常量池中没有，那就在常量池中创建一个，然后再到堆中创建一个，而 `new String("hello")` 返回的是堆中对象的引用，  
>这个新的对象的内容和常量池一致，但它是堆中的独立对象  
>所以不管常量池中有没有该字符串，`new String("xxx")` 都会造成堆和常量池中各有一个副本

```java
String str1 = "abc";
String str2 = new String("abc");
System.out.println(str1 == str2); // false，引用地址不同
```

****
## 5. intern()

>首先它会在字符串常量池中查找是否有内容相同的字符串，如果有就返回常量池中的那个字符串引用，如果没有就创建一个引用指向该字符串，并返回这个引用，所以 `intern()` 之后，返回的一定是常量池中的字符串引用

```java
String a = new String("hello");
String b = "hello";

System.out.println(a == b);          // false
System.out.println(a.intern() == b); // true
```

```java
String c = new String("hello word"); // 在常量池和堆中都会创建 "hello word" 
String d = c.intern(); // 此时常量池中已经拥有了 "hello word" 
String e = "hello word";  
System.out.println(c == d); // false c指向的是堆中的，d指向的是常量池中的 
System.out.println(d == e); // true
```

>需要注意的是Java7之后字符串常量池就从方法区中移到了堆内存中，`intern` 也从直接复制字符串变成存入引用，所以当常量池中没有对应的相同的字符串时，是可以存在 `c==d` 输出为 true 的情况的

>因为在new一个字符串对象时会默认在常量池和堆中同时存放相同的字符串(两者引用不同)，

```java
String s1 = new StringBuilder("inter").append("nTest").toString();  
String s2 = s1.intern();  
System.out.println(s1 == s2); // true
```

>因为通过拼接的方式，所以字符串常量池中最开始只会存在 inter ，当使用 intern 后 s2 指向的是常量池中指向堆中 internTest 的引用，也就是此时 s2 的引用和 s1 的引用相同

****

## 6. 字符串的拼接

### 6.1 使用 + 号拼接

>在 Java 中，`+` 运算符拼接字符串，其实底层是通过 `StringBuilder` 实现的

#### 6.1.1 全是字面量的拼接

```java
String str = "Hello" + "World";
```

>拼接结果 `"HelloWorld"` 直接存入字符串常量池中，因为完全在编译期间完成，JVM 运行时只加载常量

****
#### 6.1.2 包含变量的拼接

>这类拼接发生在运行时，编译器不会做合并优化

```java
String a = "Hello";
String b = "World";
String c = a + b;

编译器会将这段代码翻译成类似下面的形式：

String c = new StringBuilder()
              .append(a)
              .append(b)
              .toString();
```

>这是由 Java 编译器（javac）生成的逻辑，它使用 `StringBuilder` 来提升性能，避免频繁创建新 `String` 对象

****

#### 6.2 StringBuilder

>

****
## 7.  字符串的实现

>Java 中的字符串都是 `String` 类的对象，而 `String` 的本质是用一个数组（`char[]` 或 `byte[]`）来存储字符数据

### 7.1 字面量字符串怎么变成String的

>例如，编译器会把 `"hello"` 当作一个字符串常量加入到 `.class` 文件的常量池中， JVM 会检查字符串常量池中是否已经有 `"hello"`，字面量字符串是 String 的对象 ，如果有就直接复用那个对象引用，如果没有就在堆中创建对象，并将引用存入常量池
>JDK 8 之前使用 `char[]` 保存字符，JDK 9+ 使用 `byte[]`

****
### 7.2 字符串是怎么从 `char[]` 或 `byte[]` 构建的

>