
## 1. String类

>String 类代表字符串，Java 程序中的所有字符串字面值（如 "abc" ）都作为此类的实例实现，字符串是常量，它们的值在创建之后不能更改

****
## 2. String的不可变性

>`String` 对象一旦被创建，其内容是不可更改的，就算修改了字符串的值，实际上也是创建了一个新的对象，原对象保持不变，而接收变量的那个引用指向新的对象

![](images/字符串/file-20250422093106.png)

>String类是被final修饰的，它不允许被继承，其次`String` 类内部定义了一个用来存储字符串内容的字节数组（在 Java 9 之后为 `byte[]`，在此之前为 `char[]`），该数组被 `private` 和 `final` 修饰，`final` 关键字保证了数组引用在对象创建后不可更改，也就是说它始终指向同一个数组，无法重新赋值，`private` 关键字限制了对数组的直接访问，防止外部程序绕过方法直接修改内容，所以对字符串进行修改操作（如拼接、截取等）时，实际上都会创建一个新的 `String` 对象，而不是在原对象上进行更改

****
## 3. 字符串常量池

> `String` 是不可变的对象，如果 JVM 每次都创建一个新的 `String` 对象，那么相同的就会在内存中存在两份，浪费空间，当JVM 将所有的字符串字面量放入字符串常量池中后，如果已经存在相同的就直接返回已有引用避免重复创建具有相同内容的对象

>如果是字符串字面量编译期就直接放入常量池，或者使用 `intern()` 方法在运行期将堆中的字符串手动加入常量池，但是所有的相同字符串字面量只会在常量池中存一份

****
## 4. 创建字符串的两种方式

### 4.1 字面量方式创建

```java
String str1 = "hello";
```

>Java 提供了一个字符串常量池（String Constant Pool），当使用双引号创建字符串时 JVM 会先在字符串常量池中查找是否已经存在相同内容的字符串对象，如果存在就直接返回引用，不存在就创建一个新的对象放进去

```java
String str1 = "abc";
String str2 = "abc";
System.out.println(str1 == str2); // true，两个变量引用的是常量池中的同一个对象
```

****
### 4.2 new 方式创建

```java
String str3 = new String("hello");
```

>这种方式会在堆内存中创建一个新的字符串对象，即使常量池中已经有相同内容的字符串，`new` 也会强制创建一个新的实例，这个 `new` 出来的字符串不会放到常量池中，而是放在堆中，  
>如果常量池中没有，那就在常量池中创建一个，然后再到堆中创建一个，而 `new String("hello")` 返回的是堆中对象的引用，  
>这个新的对象的内容和常量池一致，但它是堆中的独立对象  
>所以不管常量池中有没有该字符串，`new String("xxx")` 都会造成堆和常量池中各有一个副本

```java
String str1 = "abc";
String str2 = new String("abc");
System.out.println(str1 == str2); // false，引用地址不同
```

****
## 5. intern()

>首先它会在字符串常量池中查找是否有内容相同的字符串，如果有就返回常量池中的那个字符串引用，如果没有就创建一个引用指向该字符串，并返回这个引用，所以 `intern()` 之后，返回的一定是常量池中的字符串引用

```java
String a = new String("hello");
String b = "hello";

System.out.println(a == b);          // false
System.out.println(a.intern() == b); // true
```

```java
String c = new String("hello word"); // 在常量池和堆中都会创建 "hello word" 
String d = c.intern(); // 此时常量池中已经拥有了 "hello word" 
String e = "hello word";  
System.out.println(c == d); // false c指向的是堆中的，d指向的是常量池中的 
System.out.println(d == e); // true
```

>需要注意的是Java7之后字符串常量池就从方法区中移到了堆内存中，`intern` 也从直接复制字符串变成存入引用，所以当常量池中没有对应的相同的字符串时，是可以存在 `c==d` 输出为 true 的情况的

>因为在new一个字符串对象时会默认在常量池和堆中同时存放相同的字符串(两者引用不同)，

```java
String s1 = new StringBuilder("inter").append("nTest").toString();  
String s2 = s1.intern();  
System.out.println(s1 == s2); // true
```

>因为通过拼接的方式，所以字符串常量池中最开始只会存在 inter ，当使用 intern 后 s2 指向的是常量池中指向堆中 internTest 的引用，也就是此时 s2 的引用和 s1 的引用相同

****

## 6. 字符串的拼接

### 6.1 使用 + 号拼接

>在 Java 中，`+` 运算符拼接字符串，其实底层是通过 `StringBuilder` 实现的，所以在拼接时会在堆中新建一个 `StringBuilder` 对象

#### 6.1.1 全是字面量的拼接

```java
String str = "Hello" + "World";
```

>拼接结果 `"HelloWorld"` 直接存入字符串常量池中，因为完全在编译期间完成，JVM 运行时只加载常量

![](images/字符串/file-20250423164215.png)

>给 s2 加上 final 后，s2 成为了常量，它不再是变量，所以 s3 的拼接是在编译阶段完成的（可看作 s3 = "a" + "b"），输出结果为 ture

****
#### 6.1.2 包含变量的拼接

>这类拼接发生在运行时，编译器不会做合并优化，直接生成一个新的 `String` 对象放在堆中

```java
String a = "Hello";
String b = "World";
String c = a + b;

编译器会将这段代码翻译成类似下面的形式：

String c = new StringBuilder()
              .append(a)
              .append(b)
              .toString();
```

>这是由 Java 编译器（javac）生成的逻辑，它使用 `StringBuilder` 来提升性能，避免频繁创建新 `String` 对象

****
## 7.  字符串的实现

>Java 中的字符串都是 `String` 类的对象，而 `String` 的本质是用一个数组（`char[]` 或 `byte[]`）来存储字符数据

### 7.1 字面量字符串怎么变成String的

>例如，编译器会把 `"hello"` 当作一个字符串常量加入到 `.class` 文件的常量池中， JVM 会检查字符串常量池中是否已经有 `"hello"`，字面量字符串是 String 的对象 ，如果有就直接复用那个对象引用，如果没有就在堆中创建对象，并将引用存入常量池
>JDK 8 之前使用 `char[]` 保存字符，JDK 9+ 使用 `byte[]`

****
### 7.2 String底层由char[]优化成byte[]

>Java 9 以前，String 是用  `char []` 实现的，之后改成了 byte 型数组实现，并增加了 coder 来表示编码，从 `char[]` 到 `byte[]`最主要的目的是节省字符串占用的内存空间

****

## 8. String的构造器

### 8.1 从char[]构造

```java
char[] c = {'H', 'e', 'l', 'l', 'o', '!'};
String str = new String(c);
```

![](images/字符串/file-20250422212358.png)

>检查传入的字符属于哪个编码的范围，然后决定使用哪种编码，决定好后就把 `char[]` 转换成 `byte[]` 作为原始字符数据的编码存储形式存储在 `String` 对象中

![](images/字符串/file-20250422213548.png)

****

### 8.2 从byte[]构造

```java
byte[] bytes = {72, 101, 108, 108, 111}; // "Hello"
String str = new String(bytes);
```

![](images/字符串/file-20250422214021.png)

>`String` 会根据传入的 `charset` 创建对应的解码器，把 `byte[]` 中存储的编码解码成相应的字符，

![](images/字符串/file-20250422214940.png)

>为了节省内存，Java就会把`char[]` 转换成 `byte[]` 存储在 `String` 对象中，所以这其实是个`byte[]`->`char[]`->`byte[]`的过程

>因为大部分情况下传入的`byte[]`是原始数据，它是经过编码后的结果，如果直接使用只会得到他的二进制码，所以在底层需要将它转换成人能够识别的字符，知道每个字节代表的是什么，然后再编码成计算机能够读懂的二进制码

****

## 9. 字符串的乱码

>字符串乱码本质上是使用错误的编码方式去解读字节流

![](images/字符串/file-20250423135639.png)

>对一个字符串使用GBK的编码方式编码，然后再使用UTF-8进行解码，就会导致出现乱码

![](images/字符串/file-20250423140214.png)

>通过 `String` 构造器对字节流进行编码和解码时可以使用 `""` 手动输入想用的编码方式，也可以使用底层自带的默认编码方式，

![](images/字符串/file-20250423140319.png)

![](images/字符串/file-20250423140522.png)

****

## 10. 字符串的常用方法

### 10.1 char charAt(int index)

>获取字符串中指定位置（索引处）的字符

![](images/字符串/file-20250423142827.png)

****
### 10.2 int length()

>用于获取字符串中字符的数量

![](images/字符串/file-20250423142953.png)

****
### 10.3 boolean isEmpty()

>用于判断字符串是否为空（即长度为 0）

![](images/字符串/file-20250423143156.png)

****
### 10.4 boolean equals(Object anObject)

>判断两个字符串内容是否相等

![](images/字符串/file-20250423143452.png)

****
### 10.5 boolean equalsIgnoreCase(String anotherString)

>忽略大小写的情况下判断两个字符串的内容是否相等

![](images/字符串/file-20250423143709.png)

****
### 10.6 boolean contains(CharSequence s)

>判断当前字符串中是否包含某个子字符串

![](images/字符串/file-20250423143944.png)

****

### 10.7 boolean startsWith(String prefix)

>判断当前字符串是否以某个字符串开头

![](images/字符串/file-20250423144434.png)

****
### 10.8 boolean endsWith(String suffix)

>用来判断当前字符串是否以指定的后缀结尾

![](images/字符串/file-20250423144544.png)

****
### 10.9 int compareTo(String anotherString)

>两个字符串按照字典顺序比较大小，返回一个整数，表示两个字符串的字典顺序，如果两个字符串相等返回 0， 如果当前字符串大于 `anotherString` 返回正整数，如果当前字符串小于 `anotherString` 返回负整数

![](images/字符串/file-20250423144924.png)

>该方法通过逐个比较两个字符串的每个字符，进行相减，因为大小写字母的Unicode值不一样，所以需要区分大小写

****
### 10.10 int compareToIgnoreCase(String str)

>两个字符串按照字典顺序比较大小，比较时忽略大小写

![](images/字符串/file-20250423145206.png)

****
### 10.11 int indexOf(String str, int fromIndex)

>从当前字符串的 `fromIndex` 下标开始往右搜索，获取当前字符串中 `str` 字符串的第一次出现处的下标

![](images/字符串/file-20250423145542.png)

****
### 10.12 int lastIndexOf(String str, int fromIndex)

>从当前字符串的 `fromIndex` 下标开始往左搜索，获取当前字符串中 `str` 字符串的最后一次出现处的下标

![](images/字符串/file-20250423150002.png)

****
### 10.13 byte[] getBytes()

>将字符串转换成字节数组，其实就是对字符串进行编码，默认按照系统默认字符集

![](images/字符串/file-20250423151052.png)

****
### 10.14 byte[] getBytes(String charsetName)

>将字符串按照指定字符集的方式进行编码

![](images/字符串/file-20250423151222.png)

****
### 10.15 byte[] getBytes(Charset charset)

>将字符串按照指定编码转换为字节数组

![](images/字符串/file-20250423151440.png)

****
### 10.16 char[] toCharArray()

>将字符串转换字符数组

![](images/字符串/file-20250423151612.png)

****
### 10.17 String toLowerCase()

>转小写

****
### 10.18 String toUpperCase()

>转大写

![](images/字符串/file-20250423151843.png)

****
### 10.19 String concat(String str)

>将当前字符串和另一个字符串连接起来，因为字符串是不能改变的，所以返回的是源字符串和 str 拼接后的新字符串

![](images/字符串/file-20250423153426.png)

**与 + 对比**

>这两种拼接的方式很类似，都会创建一个新的字符串，并且都放在堆中（用 + 拼接两个引用对象），不会进入常量池，所以进行多次的拼接操作时会创建多个 `String` 对象，导致占用很多内存  
>但 + 号拼接更灵活，不会出现空指针异常的情况

![](images/字符串/file-20250423154103.png)

![](images/字符串/file-20250423154125.png)

****
### 10.20 String substring(int beginIndex, int endIndex)

>截取字符串的一部分子字符串，范围是从 `beginIndex`（包括）到 `endIndex`（不包括）

![](images/字符串/file-20250423155318.png)

****
### 10.21 static String join

>将多个字符串以某个分隔符连接

![](images/字符串/file-20250423155953.png)

****
### 10.22 static String valueOf

>将非字符串转换成字符串

![](images/字符串/file-20250423160735.png)

****
## 11. StringBuilder

>`StringBuilder` 是 Java 中一个用于构建可变字符串的类，在原有对象上修改，效率更高，通常用于频繁拼接字符串的场景

### 11.1 底层结构

![](images/字符串/file-20250423173616.png)

![](images/字符串/file-20250423173716.png)

>`StringBuilder` 的父类中的核心字段为`char[] value` 和 `int count`，分别用来存储字符内容和记录当前字符串的长度

![](images/字符串/file-20250423173927.png)

![](images/字符串/file-20250423173905.png)

>在创建 `StringBuilder` 对象时会传入一个 16，这个就是 `StringBuilder` 的默认容量，如果后续拼接字符串大于默认长度后就会进行扩容操作

![](images/字符串/file-20250423175631.png)

>先创建了一个长度为32的字符串，已经大于默认的容量了，所以肯定会进行扩容操作，底层会先对原容量（16）进行 ×2 + 2 的操作，此时的数组容量就成了 34，大于了32  
>当minGrowth > prefGrowth 时，可能就不是进行 ×2 + 2 的操作了，主要是看那个 growth（传进去后的参数名是minGrowth）

![](images/字符串/file-20250423180752.png)

![](images/字符串/file-20250423181137.png)




