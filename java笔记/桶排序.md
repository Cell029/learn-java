
>桶排序是一种分治的思想，把数据按照范围分到桶中，对桶中的数据进行排序，然后再按照桶的顺序将数据合并输出

>通常使用公式 桶编号 = (元素值 - 最小值) / 桶宽度 来确定桶的范围，但主要是根据数据的分布范围和预期桶的个数来设计桶的范围

```java
public static void bucketSort(int[] arr, int bucketCount) {  
    // 找到数组中的最大值和最小值  
    int min = arr[0], max = arr[0];  
    for (int i = 1; i < arr.length; i++) {  
        if (arr[i] > max) {  
            max = arr[i];  
        }  
        if (arr[i] < min) {  
            min = arr[i];  
        }  
    }  
  
    // 创建桶  
    List<List<Integer>> bucketList = new ArrayList<>();  
    for (int i = 0; i < bucketCount; i++) {  
        bucketList.add(new ArrayList<>());  
    }  
  
    // 为了防止一个数据出现在两个桶中，所以采取左闭右开的方式存储，为了能把数组的边界值包进去，实际范围就需要比边界值大一点，所以要 max-min+1    
    double range = (double)(max - min + 1) / bucketCount;  
    // 将元素按照范围添加进桶中  
    for (int i = 0; i < arr.length; i++) {  
        int bucketIndex = (int)((arr[i] - min) / range);
        // 桶的范围从最小值开始 [min~min+range)        
        bucketList.get(bucketIndex).add(arr[i]);  
    }  
  
    // 对桶内元素进行快速排序  
    int index = 0;  
    for (int i = 0; i < bucketCount; i++) {  
        int[] bucketArr = listToArray(bucketList.get(i));  
        quickSort(bucketArr, 0, bucketArr.length - 1);  
  
        // 打印每个桶的内容  
        System.out.println("第 " + i + " 个桶中的排序后元素：" + Arrays.toString(bucketArr));  
  
        for (int j = 0; j < bucketArr.length; j++) {  
            arr[index++] = bucketArr[j];  
        }  
    }  
}  
  
public static int[] listToArray(List<Integer> list) {  
    int[] arr = new int[list.size()];  
    for (int i = 0; i < list.size(); i++) {  
        arr[i] = list.get(i);  
    }  
    return arr;  
}  
  
public static void quickSort(int[] arr, int left, int right) {  
    if (left >= right) return;  
    int pivot = arr[left];  
    int i = left, j = right;  
  
    while (i < j) {  
        while (i < j && arr[j] > pivot) {  
            j--;  
        }  
        if (i < j) {  
            arr[i++] = arr[j];  
        }  
        while (i < j && arr[i] < pivot) {  
            i++;  
        }  
        if (i < j) {  
            arr[j--] = arr[i];  
        }  
    }  
    arr[i] = pivot;  
    quickSort(arr, left, i - 1);  
    quickSort(arr, i + 1, right);  
}
```

>因为桶排序无法提前确定桶中的元素有多少个，所以没法提前确定一个桶的大小，因此用List来创建桶，再用一个List接收，就不需要写多个List在程序中，通过循环存入即可

>计算桶的范围时使用`Double`接收可以让范围更加精确，不至于出现太多的损失导致某些较大的值可能不存在桶的范围中，用`int`接收会自动向下转型，导致丢失一些精度，组数多了就会缩小一些范围


>桶排序的时间复杂度取决于很多因素，找最大最小值为O(n)，把元素放进桶里O(n)，拼接桶内元素O(n)，桶内部排序（取决于使用的什么排序），桶排序的优势就是存在把所有元素平局放进每个桶中，让每个桶内的元素较少，降低桶内排序的时间，所以最好的情况可以把桶内的排序时间复杂度看作O(1)（桶内元素够小），最坏情况则是所有元素都在一个桶中，此时就完全取决于桶内排序的时间复杂度了，如果运气不好就会和快速排序的最差时间复杂度一样为O(n<sup>2</sup>)