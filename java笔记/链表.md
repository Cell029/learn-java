
>链表是由一个一个的节点组成的，每个节点包含两个字段，其中一个字段 `data` 表示真实存储的数据，另外一个字段 `next` 表示指向下一个节点的指针，`data` 和 `next` 两者一起组成链表当中的节点( `Node` )

```java
class Node {
    int data;    // 数据域
    Node next;   // 指针域

    Node(int data) {
        this.data = data;
        this.next = null;
    }
}
```

# 1. 单向链表

```java
public class SingleLinkedList {  
    private Node head; // 链表头指针  
  
    // 构造函数，初始化为空链表  
    public SingleLinkedList() {  
        head = null;  
    }  
  
    // 头插法插入元素  
    // 最早插入的元素会变成链表的尾部元素 ... 4 3 2 1 0    
    // 每次在 head 节点的位置进行插入，插入后更新 head 节点，让刚插入的节点变成 head 节点
    public void insertAtHead(int data) {  
        Node newNode = new Node(data);  
        newNode.next = head; // 让新的节点指向头节点原来指向的节点  
        head = newNode; // 更新头节点的指向，让头节点指向新插入的节点  
    }  
  
    // 尾插法插入元素  
    public void insertAtTail(int data) {  
        Node newNode = new Node(data);  
        // 如果此时链表中没有节点，就要让头指针指向第一个添加的节点  
        // 后续插入节点就不需要动头指针了  
        if (head == null) {  
            head = newNode;  
            return;  
        }  
        // 从头节点开始向后遍历，遍历到最后一个节点后再将这个节点的指针指向新插入的节点 
        Node temp = head;  
        while (temp.next != null) {  
            temp = temp.next; // 让 temp 指针逐渐后移  
        }  
        // 当 temp 的指针为空时，证明此时的 temp 是最后一个节点  
        temp.next = newNode;  
    }  
  
    // 查找元素  
    public int search(int data) {  
        int count = 0;  
        Node temp = head;  
        while (temp != null) {  
            count++;  
            if (temp.data == data) {  
                return count;  
            } else {  
                temp = temp.next;  
            }  
        }  
        return -1;  
    }  
  
    // 删除节点  
    public void deleteByValue(int data) {  
        if (head == null) {  
            return;  
        }  
        if (head.data == data) {  
            head = head.next;  
            return;  
        }  
        // 删除节点需要将上个节点指向本节点的下个节点，所以需要创建两个临时节点  
        Node preNode = head; // 当前节点的上一个节点  
        Node currNode = head.next; // 当前节点  
        while (currNode != null) {  
            if (currNode.data == data) {  
                preNode.next = currNode.next; // 让上个节点指向当前节点的下个节点  
            }  
            // 节点后移  
            currNode = currNode.next;  
            preNode = preNode.next;  
        }  
    }  
  
    // 遍历元素  
    public void traverse() {  
        Node temp = head;  
        while (temp != null) {  
            System.out.println(temp.data);  
            temp = temp.next;  
        }  
        System.out.println("遍历结束");  
    }  
  
    // 获取链表长度  
    public int getLength() {  
        Node temp = head;  
        int length = 0;  
        while (temp != null) {  
            length++;  
            temp = temp.next;  
        }  
        return length;  
    }  
}  
  
class Node {  
    int data;    // 数据域  
    Node next;   // 指针域  
  
    // 构造函数  
    Node(int data) {  
        this.data = data;  
        this.next = null;  
    }  
}

SingleLinkedList list = new SingleLinkedList();  
list.insertAtTail(3);  
list.insertAtTail(2);  
list.insertAtTail(1);  
list.insertAtTail(4);  
list.insertAtTail(5);  
  
list.traverse(); // 3 2 1 4 5 
System.out.println("链表长度:" + list.getLength()); // 5 
  
// 查找元素  
int data = 1;  
System.out.println(data + "是第" + list.search(data) + "个元素"); 
// 1是第3个元素
  
// 删除元素  
list.deleteByValue(1);  
list.traverse(); // 3 2 4 5
```

****
# 2. 双向链表

>双向链表和单链表的区别就是它的指向有两个方向，而单链表只有一个方向，在双向链表的节点当中会有两个指向其他同样节点的变量，一个指向前一个节点，一个指向后一个节点

```java
public class DoubleLinkedList {  
    private DoubleNode head; // 链表头指针  
    private DoubleNode tail; // 链表尾指针  
  
    // 构造函数：初始化为空链表  
    public DoubleLinkedList() {  
        this.head = null;  
        this.tail = null;  
    }  
  
    // 头插法插入节点  
    public void insertAtHead(int data) {  
        DoubleNode newNode = new DoubleNode(data);  
        if (head == null) {  
            head = tail = newNode;  
        } else {  
            newNode.next = head;  
            head.prev = newNode;  
            head = newNode;  
        }  
    }  
  
    // 尾插法  
    public void insertAtTail(int data) {  
        DoubleNode newNode = new DoubleNode(data);  
        if (tail == null) {  
            head = tail = newNode;  
        } else {  
            tail.next = newNode;  
            newNode.prev = tail;  
            tail = newNode;  
        }  
    }  
  
    // 根据元素删除节点  
    public void deleteByValue(int data) {  
        if (head == null) {  
            return;  
        }  
        DoubleNode temp = head;  
        while (temp != null) {  
            if (temp.data == data) {  
                // 如果是头节点  
                if (temp == head) {  
                    head = head.next; // 将头节点后移  
                    if (head != null) {  
                        head.prev = null; // 把当前头节点的前一个节点设为空，即删除  
                    } else {  
                        tail = null; // 头节点为空说明链表为空，把尾节点也设为空  
                    }  
                }  
                // 如果是尾节点  
                else if (temp == tail) {  
                    tail = tail.prev; // 尾节点前移  
                    if (tail != null) {  
                        tail.next = null; // 将当前尾节点的后一个节点设为空，即删除  
                    }  
                }  
                // 如果是中间节点，删除 temp 节点，需要把它的前后节点的指向都修改  
                else {  
                    // 当前节点的上一个节点的 next 指向当前节点的下一个节点，  
                    // 即当前节点的下一个节点要成为当前节点的上一个节点的下一个节点  
                    temp.prev.next = temp.next;  
                    // 当前节点的下一个节点的 prev 指向当前节点的上一个节点，  
                    // 即当前节点的上一个节点要成为当前节点的下一个节点的上一个节点  
                    temp.next.prev = temp.prev;  
                }  
                return; // 只删除第一个匹配的  
            }  
            // temp 节点后移  
            temp = temp.next;  
        }  
    }  
  
    // 从头查找元素  
    public boolean searchFromHead(int data) {  
        DoubleNode temp = head;  
        while (temp != null) {  
            if (temp.data == data) {  
                return true;  
            }  
            temp = temp.next;  
        }  
        return false;  
    }  
  
    // 从尾查找元素  
    public boolean searchFromTail(int data) {  
        DoubleNode temp = tail;  
        while (temp != null) {  
            if (temp.data == data) {  
                return true;  
            }  
            temp = temp.prev;  
        }  
        return false;  
    }  
  
    // 正向遍历链表  
    public void traverseForward() {  
        DoubleNode temp = head;  
        while (temp != null) {  
            System.out.print(temp.data + "<->");  
            temp = temp.next;  
        }  
        System.out.println("遍历结束");  
    }  
  
    // 反向遍历  
    public void traverseBackward() {  
        DoubleNode temp = tail;  
        while (temp != null) {  
            System.out.print(temp.data + "<->");  
            temp = temp.prev;  
        }  
        System.out.println("遍历结束");  
    }  
  
    // 获取链表长度  
    public int getLength() {  
        int length = 0;  
        DoubleNode temp = head;  
        while (temp != null) {  
            length++;  
            temp = temp.next;  
        }  
        return length;  
    }  
}  
  
class DoubleNode {  
    int data;           // 数据域  
    DoubleNode prev;    // 前一个节点指针  
    DoubleNode next;    // 后一个节点指针  
  
    public DoubleNode(int data) {  
        this.data = data;  
        this.prev = null;  
        this.next = null;  
    }  
}

DoubleLinkedList list = new DoubleLinkedList();  
list.insertAtHead(3);  
list.insertAtHead(2);  
list.insertAtHead(1);  
list.insertAtTail(4);  
list.insertAtTail(5);  
  
System.out.println("正向遍历：");  
list.traverseForward();  // 1 <-> 2 <-> 3 <-> 4 <-> 5 <-> 遍历结束  
  
System.out.println("反向遍历：");  
list.traverseBackward(); // 5 <-> 4 <-> 3 <-> 2 <-> 1 <-> 遍历结束  
  
System.out.println("链表长度：" + list.getLength()); // 输出 5  
System.out.println("查找元素4：" + list.searchFromHead(4)); // true  
System.out.println("查找元素6：" + list.searchFromTail(6)); // false  
  
list.deleteByValue(3); // 删除元素3  
System.out.println("删除3后的正向遍历：");  
list.traverseForward(); // 1 <-> 2 <-> 4 <-> 5 <-> 遍历结束
```

>和单向链表的代码比较一下，在初始化时需要添加一个尾节点，当添加了两个节点后才能体现出区别，但是尾节点不是必须的，只是添加了尾节点后可以从尾部开始操作，让双向链表的特点得到发挥，最典型的就是尾插法，直接在尾节点后面添加就行，不需要像单向链表一样遍历到尾部

****
# 3. 单向循环链表

>它和普通单向链表的最大区别是最后一个节点的 `next` 不再是 `null`，而是指向头节点， 因此它形成了一个**闭环结构**，可以循环遍历

```java

```