
# 1. 栈

>栈是一种特殊的线性表，它只允许在一端进行插入和删除操作，它遵循的原则叫做：后进先出（LIFO, Last In First Out）， 最后压入栈的元素，最先被弹出， 先压入栈的元素，最后才被弹出

## 1.1 基于数组实现

- 用一个数组 `elements` 存储数据。
- 用一个整型变量 `size` 表示当前栈中元素的数量，同时也可以视为**下一个要插入元素的位置**。
- 栈顶就是数组的最后一个元素。
- `push` 往数组后面加，`pop` 从数组后面取

```java 
public class ArrayStack {  
    private int[] elements; // 用数组存元素  
    private int size;       // 当前元素数量  
    private static final int DEFAULT_CAPACITY = 10; // 初始容量  
  
    public ArrayStack() {  
        elements = new int[DEFAULT_CAPACITY];  
    }  
  
    // 扩容方法  
    public void grow() {  
        int[] newArray = new int[elements.length * 2];  
        for (int i = 0; i < elements.length; i++) {  
            newArray[i] = elements[i];  
        }  
        elements = newArray;  
    }  
  
    // 判断栈是否为空  
    public boolean isEmpty() {  
        return size == 0;  
    }  
  
    // 压栈操作  
    public void push(int value) {  
        if (size == elements.length) {  
            grow();  
        }  
        elements[size] = value;  
        size++;  
    }  
  
    // 出栈操作  
    public int pop() {  
        if (size == 0) {  
            throw new RuntimeException("栈为空");  
        }  
        int popElement = elements[size];  
        size--;  
        return popElement;  
    }  
  
    // 查看栈顶元素  
    public int peek() {  
        if (size == 0) {  
            throw new RuntimeException("栈为空");  
        }  
        return elements[size - 1];  
    }  
  
    // 栈中元素个数  
    public int size() {  
        return size;  
    }  
}
```

>用数组实现栈的结构比较好理解，因为数组自带下标，所以出栈时直接访问最后一个下标的位置即可

```java
ArrayStack stack = new ArrayStack();  
  
System.out.println("开始入栈：");  
stack.push(10);  
stack.push(20);  
stack.push(30);  
System.out.println("当前栈顶元素是：" + stack.peek()); // 30  
  
System.out.println("出栈元素：" + stack.pop()); // 弹出 30
System.out.println("当前栈顶元素是：" + stack.peek()); // 20  
  
System.out.println("继续入栈：");  
stack.push(40);  
System.out.println("当前栈顶元素是：" + stack.peek()); // 40  
  
System.out.println("全部出栈：");  
while (!stack.isEmpty()) {  
    System.out.println(stack.pop());  
}
```

****
## 1.2 基于链表实现

```java
public class LinkedStack {  
    private static class Node {  
        int value;  
        Node next;  
  
        Node(int value, Node next) {  
            this.value = value;  
            this.next = next;  
        }  
    }  
  
    private Node top; // 栈顶  
    private int size; // 栈大小  
  
    public LinkedStack() {  
        top = null;  
        size = 0;  
    }  
  
    // 入栈（头插法）  
    public void push(int value) {  
        Node newNode = new Node(value, top);  
        top = newNode;  
        size++;  
    }  
  
    // 出栈  
    public int pop() {  
        if (top == null) {  
            throw new RuntimeException("栈为空");  
        }  
        int value = top.value;  
        top = top.next; // 类似于删除头节点，然后把下一个节点作为新的头节点  
        size--;  
        return value;  
    }  
  
    // 查看栈顶元素  
    public int peek() {  
        if (top == null) {  
            throw new RuntimeException("栈为空");  
        }  
        return top.value;  
    }  
  
    // 栈的大小  
    public int size() {  
        return size;  
    }  
}
```

```java
LinkedStack stack = new LinkedStack();  
  
System.out.println("开始入栈：");  
stack.push(100);  
stack.push(200);  
stack.push(300);  
System.out.println("当前栈顶元素是：" + stack.peek()); // 300  
  
System.out.println("出栈元素：" + stack.pop()); // 300  
System.out.println("当前栈顶元素是：" + stack.peek()); // 200  
  
System.out.println("继续入栈：");  
stack.push(400);  
System.out.println("当前栈顶元素是：" + stack.peek()); // 400  
  
System.out.println("全部出栈：");  
while (stack.size() != 0) {  
    System.out.println(stack.pop());  
}
```

****
# 2. 队列

>队列是一种特殊的线性数据结构，它的特点是先进先出（FIFO, First In First Out）

```java

```