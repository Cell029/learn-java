在Java的编译器中，大体可以分为三类：

- **前端编译器**：类似于 javac 、JDT 中的ECJ增量编译器等。就是指将`.java`的源代码编译成`.class`字节码指令的编译器。
- **后端编译器**：也就是指 JIT 即时编译器，指把字节码指令编译成机器码指令的编译器。
- **静态编译器**：类似于 Java9 中的 AOT 编译器，是指把`.java`源代码直接编译为机器码指令的编译器。
# 1. JIT 定义

>JIT（Just-In-Time Compilation，即时编译）是 Java 虚拟机（JVM）中的一项关键技术，其目的是提高 Java 程序的运行效率。JIT 编译器在程序运行时，将 Java 字节码动态编译为本地机器码，使代码能够直接在底层硬件上运行，而无需逐行解释，从而大幅提升性能。

****
# 2. JIT 的分类

>在 JVM 运行过程中采用的解释器 + 编译器混合执行的模式，其中的编译器一般是指 JIT 编译器。在 HotSpot 虚拟机中内嵌着两个 JIT 即时编译器，分别为 `Client Compiler` 与 `Server Compiler` ，也就是 C1 和 C2 编译器，JVM 在 64 位的系统中默认采用的C2编译器，也就是 `Server Compiler` 编译器。不过同样的，在程序启动的时候也可以通过参数显式指定运行时到底采用哪种编译器

- -client：指定JVM运行时采用 C1 编译器。
    - C1编译器会对字节码进行简单和可靠的优化，耗时比较短，追求编译速度。
- -server：指定JVM运行时采用 C2 编译器。
    - C2编译器会对字节码进行激进优化，耗时比较长，追求编译后的执行性能。

****
## 2.1 C1 编译器

| 特性         | 描述                       |
| ---------- | ------------------------ |
| **启动速度快**  | 编译逻辑相对简单，适合快速启动程序        |
| **编译耗时短**  | 相比 C2，优化级别低，因此编译时间短      |
| **优化策略保守** | 只做一些基础的、安全的优化            |
| **调试友好**   | 编译后保留较多调试信息，利于开发过程中的错误定位 |

### 2.1.1 C1 编译器的工作原理与执行流程

1、字节码执行初期：使用解释器

>JVM 初次执行方法时，会使用解释器对字节码逐条执行，目的是快速启动程序，避免编译延迟

2、触发编译：热点探测

>当某个方法或循环体被调用的次数达到一定阈值，JVM 就会将其认定为热点代码，此时 C1 编译器就会开始介入，将这段字节码编译为本地机器码，以提升后续运行效率

3、编译为本地代码

>C1 编译器在将字节码编译成本地机器码的过程中会对代码做出一定的改写或重组，以提升运行效率，优化后生成的机器码会保存在代码缓存中供后续调用。优化的目标包括：

- 减少不必要的计算（比如去掉无用的代码）
    
- 减少函数调用开销（比如方法内联）
    
- 提前判断条件或预测分支
    
- 尽可能减少堆内存分配
    
- 让 CPU 更容易缓存、预测下一步执行的代码路径

****
### 2.1.2 C1 编译器主要优化手段

**1、方法内联**

>方法内联是指把被调用的方法的代码直接插入到调用点，从而避免方法调用时的开销（如参数传递、压栈/出栈、返回值处理）

为什么这样优化？

>因为方法的调用是有成本的，当一个小方法被反复调用就会积累很多开销（每次调用都要压栈出栈），但如果方法很大、递归层次深、分支复杂，JIT 编译器可能会**拒绝内联**，因为内联成本反而会变高（增加代码体积，可能影响缓存局部性）

**缓存局部性：** 程序访问数据时倾向于访问空间上或时间上相邻的数据，从而更有效地利用 CPU 的高速缓存

```java
public int add(int a, int b) {
    return a + b;
}

public int compute() {
    return add(1, 2);  // 这个调用会被内联
}

// 优化后
public int compute() {
    return 1 + 2;
}
```

**2、常量传播与常量折叠**

- **常量传播**：将值已知的变量在整个表达式中用实际值代替
    
- **常量折叠**：将可以在编译阶段算出的表达式提前计算，变成一个常量

```java
public int calculate() {
    int a = 3;
    int b = 4;
    return a * b;
}

// 优化后
public int calculate() {
    return 12;  // 编译时直接计算出结果，减少不必要的运行时计算
}
```

**3、死代码消除**

>死代码指的是永远不会执行的代码，或执行后结果无影响的代码，编译器会把它们移除掉

```java
public void test() {
    int a = 5;
    a = 6;  // 上一行的赋值没意义
    if (false) { // 永远不会执行，无意义的 if 语句
        System.out.println("不会执行");
    }
}

// 优化后
public void test() {
    int a = 6;  // 合并赋值
}
```

**4、分支预测优化**

>基于解释阶段收集的运行时信息，C1 编译器可以根据某些分支更常执行哪个路径来优化代码结构

```java
public int classify(int x) {
    if (x > 0) {
        return 1;
    } else {
        return -1;
    }
}
```

>假设运行时发现 `x > 0` 的情况占 90%，则 C1 会将 “`x > 0`” 分支置于前面的位置，使 CPU 的分支预测命中率更高，避免先执行下面的 `x <= 0` 的情况

**5、去除冗余检查**

>如果某个类型检查、边界检查在逻辑上是一定会成功的，编译器就会删除这类无意义的检查操作

```java
String s = "hello";
if (s instanceof String) {
    System.out.println(s.length());
}

// 优化后
String s = "hello";
System.out.println(s.length());
```

**6、简单逃逸分析**

>逃逸分析是用来判断一个对象是否可能逃逸出当前方法作用范围的分析手段

**逃逸：**

>逃逸指的是：一个对象在创建后，是否被方法外部的代码访问到了，如果对象只在方法内部使用，没有暴露给其他线程、类或方法，就称它没有逃逸

