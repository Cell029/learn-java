
# 1. JIT 定义

>JIT（Just-In-Time Compilation，即时编译）是 Java 虚拟机（JVM）中的一项关键技术，其目的是提高 Java 程序的运行效率。JIT 编译器在程序运行时，将 Java 字节码动态编译为本地机器码，使代码能够直接在底层硬件上运行，而无需逐行解释，从而大幅提升性能。

****
# 2. JIT 的分类

>在 JVM 运行过程中采用的解释器 + 编译器混合执行的模式，其中的编译器一般是指 JIT 编译器。在 HotSpot 虚拟机中内嵌着两个 JIT 即时编译器，分别为 `Client Compiler` 与 `Server Compiler` ，也就是 C1 和 C2 编译器，JVM 在 64 位的系统中默认采用的C2编译器，也就是 `Server Compiler` 编译器。不过同样的，在程序启动的时候也可以通过参数显式指定运行时到底采用哪种编译器

- -client：指定JVM运行时采用 C1 编译器。
    - C1编译器会对字节码进行简单和可靠的优化，耗时比较短，追求编译速度。
- -server：指定JVM运行时采用 C2 编译器。
    - C2编译器会对字节码进行激进优化，耗时比较长，追求编译后的执行性能。

****
## 2.1 C1 编译器

>C1编译器主要追求稳定和编译速度，属于保守派

| 特性         | 描述                       |
| ---------- | ------------------------ |
| **启动速度快**  | 编译逻辑相对简单，适合快速启动程序        |
| **编译耗时短**  | 相比 C2，优化级别低，因此编译时间短      |
| **优化策略保守** | 只做一些基础的、安全的优化            |
| **调试友好**   | 编译后保留较多调试信息，利于开发过程中的错误定位 |

### 2.1.1 C1 编译器的工作原理与执行流程

1、字节码执行初期：使用解释器

>JVM 初次执行方法时，会使用解释器对字节码逐条执行，目的是快速启动程序，避免编译延迟

2、触发编译：热点探测

>当某个方法或循环体被调用的次数达到一定阈值，JVM 就会将其认定为热点代码，此时 C1 编译器就会开始介入，将这段字节码编译为本地机器码，以提升后续运行效率

3、编译为本地代码

>C1 编译器在将字节码编译成本地机器码的过程中会对代码做出一定的改写或重组，以提升运行效率，优化后生成的机器码会保存在代码缓存中供后续调用。优化的目标包括：

- 减少不必要的计算（比如去掉无用的代码）
    
- 减少函数调用开销（比如方法内联）
    
- 提前判断条件或预测分支
    
- 尽可能减少堆内存分配
    
- 让 CPU 更容易缓存、预测下一步执行的代码路径

****
### 2.1.2 C1 编译器主要优化手段

**1、方法内联**

>方法内联是指把被调用的方法的代码直接插入到调用点，从而避免方法调用时的开销（如参数传递、压栈/出栈、返回值处理）

为什么这样优化？

>因为方法的调用是有成本的，当一个小方法被反复调用就会积累很多开销（每次调用都要压栈出栈），但如果方法很大、递归层次深、分支复杂，JIT 编译器可能会**拒绝内联**，因为内联成本反而会变高（增加代码体积，可能影响缓存局部性）

**缓存局部性：** 程序访问数据时倾向于访问空间上或时间上相邻的数据，从而更有效地利用 CPU 的高速缓存

```java
public int add(int a, int b) {
    return a + b;
}

public int compute() {
    return add(1, 2);  // 这个调用会被内联
}

// 优化后
public int compute() {
    return 1 + 2;
}
```

**2、常量传播与常量折叠**

- **常量传播**：将值已知的变量在整个表达式中用实际值代替
    
- **常量折叠**：将可以在编译阶段算出的表达式提前计算，变成一个常量

```java
public int calculate() {
    int a = 3;
    int b = 4;
    return a * b;
}

// 优化后
public int calculate() {
    return 12;  // 编译时直接计算出结果，减少不必要的运行时计算
}
```

**3、死代码消除**

>死代码指的是永远不会执行的代码，或执行后结果无影响的代码，编译器会把它们移除掉

```java
public void test() {
    int a = 5;
    a = 6;  // 上一行的赋值没意义
    if (false) { // 永远不会执行，无意义的 if 语句
        System.out.println("不会执行");
    }
}

// 优化后
public void test() {
    int a = 6;  // 合并赋值
}
```

**4、分支预测优化**

>基于解释阶段收集的运行时信息，C1 编译器可以根据某些分支更常执行哪个路径来优化代码结构

```java
public int classify(int x) {
    if (x > 0) {
        return 1;
    } else {
        return -1;
    }
}
```

>假设运行时发现 `x > 0` 的情况占 90%，则 C1 会将 “`x > 0`” 分支置于前面的位置，使 CPU 的分支预测命中率更高，避免先执行下面的 `x <= 0` 的情况

**5、去除冗余检查**

>如果某个类型检查、边界检查在逻辑上是一定会成功的，编译器就会删除这类无意义的检查操作

```java
String s = "hello";
if (s instanceof String) {
    System.out.println(s.length());
}

// 优化后
String s = "hello";
System.out.println(s.length());
```

**6、简单逃逸分析**

>逃逸分析是用来判断一个对象是否可能逃逸出当前方法作用范围的分析手段

**逃逸：**

>逃逸指的是：一个对象在创建后，是否被方法外部的代码访问到了，如果对象只在方法内部使用，没有暴露给其他线程、类或方法，就称它没有逃逸

**同步消除**

>如果编译器能判断某个加锁对象未逃逸（只有当前线程能访问），就可以去掉不必要的 `synchronized` 锁

```java
public void method() {
    synchronized (new Object()) {
        // 只在当前线程使用，不需要加锁
    }
}
```

****
## 2.2 C2 编译器

>C2 编译器是 HotSpot JVM 中的高级即时编译器，目标是最大化运行效率，适用于需要高性能的服务器端程序，编译成本较高，但运行效率高，C2 编译器则主要是追求编译后的执行性能，属于激进派

**栈上分配**

>Java 中默认对象是分配在堆上的，要经过垃圾回收，但如果对象未逃逸，则可以在栈上分配，方法执行完毕后自动销毁，无需 GC，减轻 GC 的压力

**标量替换**

>将对象的字段当作局部变量来单独处理，不再创建对象本体

```java
public void test() {
    Point p = new Point(1, 2);  // 未逃逸，可栈上分配
    System.out.println(p.x);
}
// 编译器可能会把这个 Point 对象转换成两个局部变量：int x = 1; int y = 2; 而不创建 Point 对象
```

****
## 2.3 性能信息采集机制（Profiling）

>Profiling 就是 JVM 在执行代码的同时记录谁来了多少次？走哪条路？什么类型的参数？然后告诉 C2 编译器：这是热点路径、这是稳定类型，可以优化了

- **解释器阶段：不做 Profiling
- **C1 编译**：会在生成的机器码中插入特定指令来采集运行数据
- **C2 编译**：读取这些数据，做更激进、更深入的优化

**工作原理：**

1、 JVM 检测某个方法开始变热（调用次数增加）

2、 JVM 启动 C1 编译，设置为带 Profiling 模式

3、 C1 在生成的机器码中加入记录指令：

- 判断分支命中次数（加计数器）
- 记录方法调用目标（类信息）
- 捕捉对象逃逸行为等    

4、 后续每次执行该方法时都会**边执行边记录数据**

5、 方法变得更热时，进入 C2 编译阶段

6、 C2 编译器读取这些 Profiling 数据，执行高级优化



****
# 3. 分层编译

>Java 7 之前，开发人员需要根据业务场景选择合适的编译器，对于启动性能要求比较高，不长期运行的场景选择 C1，对应 -client 模式。对于长期运行，峰值性能要求比较高的场景选择 C2，对应  -server 模式。Java 7 开始引入了分层编译，结合 C1 和 C2 的优势，追求启动性能和峰值性能的一个平衡

1、先由解释器执行字节码
    
2、然后通过 C1 编译器做快速编译
    
3、最后将热点代码交由 C2 进一步优化编译

## 3.1 分层编译中的 5 层运行路径

**HotSpot JVM 中的分层编译模型通常包含 5 个层级：**

| 层级（Level） | 名称          | 编译器    | 说明                                |
| --------- | ----------- | ------ | --------------------------------- |
| 0         | 解释执行        | 无（解释器） | 方法刚刚开始执行，JVM 使用解释器执行字节码           |
| 1         | C1 编译，无分析   | C1     | 初级编译，仅做最基础优化                      |
| 2         | C1 编译，带性能分析 | C1     | 会插入 profiling 代码收集运行信息（如类型、分支命中等） |
| 3         | 过渡状态        | —      | 内部过渡机制                            |
| 4         | C2 编译       | C2     | 使用 C1 收集的数据进行深度优化，生成高性能机器码        |

>编译出的代码执行效率从大到小依次是：第4层 > 第1层 > 第2层 > 第3层

**五种运行路径及其典型场景**

**1、常规路径：解释器 -> C1（3层）-> C2（4层）**

>大多数热点方法按正常路径执行：先由解释器执行 -> 再进入带 profiling 的 C1（第 3 层） -> profiling 数据充分后，交由 C2 优化编译

**2、简单方法：解释器 -> C1（3层）-> 放弃 C2，退回用 C1（1层）**

>有些简单方法（如 getter/setter）虽然被执行很多次，但收集不到有用的 profiling 数据（如分支跳转率、对象分配率等），JVM 会判断：该方法的 C1 和 C2 编译版本执行效率差不多，就跳过 C2 编译（编译成本高），回退为 C1（1层）版本运行

**3、C1 忙碌：解释器 -> 跳过 C1，直接进入 C2（4层）**

>当 C1 编译线程过于忙碌或积压时，解释器执行时会收集 profiling 数据，JVM 会直接将热点方法交给 C2 编译器，跳过 C1，以此防止编译队列阻塞，提升执行效率

**4、C2 忙碌：解释器 -> C1（2层）-> C1（3层）**

>当 C2 编译器繁忙（或被限制）时，JVM 为了避免长时间停留在解释器执行，会先用较低层级的 C1（2层）做初步编译，待条件允许后再进入 C1（3层），为后续 C2 编译做准备

**5、反优化路径：C2 编译 -> 回退为解释器（反优化）**

>有时 C2 编译器做了一些激进优化（如分支预测、类型猜测等），但在实际运行过程中预测失败，比如预测一个 `if` 条件总是为 true，但后来大量变为 false，JVM 会将该方法反优化，退回解释器，再重新收集数据并评估是否需要再次编译

****
# 4. AOT 定义

>在程序运行之前，将 Java 字节码（`.class` 或 `.jar`）提前编译为本地机器码，从而避免或减少 JVM 在运行时对代码的即时编译（JIT）需求。也就是说 JIT 是边运行边编译，AOT 是一开始就编译好。

****
# 5. AOT 编译的实现方式

AOT 编译的过程通常包括以下步骤：

1、**编译过程**：在构建过程中，将字节码转换为机器码，这是在开发和打包阶段进行的。

2、**保存机器码**：编译的机器码被存储在本地文件中，成为已编译的应用程序的一部分。

3、**运行时加载**：在应用程序启动时，JVM 会直接加载预编译好的机器码，而无需再进行 JIT 编译。

4、**动态部分**：AOT 编译的程序通常会和 JIT 编译混合使用。虽然大部分代码已经预编译成机器码，JIT 编译仍然可以在程序运行时处理那些未预编译的部分或更为动态的代码。

****
# 6. AOT 的优点

**优点：**

1、**启动速度快**：

>编译后的二进制文件是直接可执行的，无需启动 JVM

2、 **更低的内存占用**：

>无需 JVM 运行时的额外内存开销

3、 **可预期的性能**：

>编译时的优化让性能稳定，不受运行时环境的变化影响

****
# 7. 无法全部使用 AOT 编译

>虽然 AOT 编译在启动性能和资源消耗方面有显著优势，但并不是所有场景都适合完全使用 AOT

**1、缺乏运行时信息的动态优化**

>JIT 编译的优势在于能够根据程序的实际运行情况做出精细的动态优化

[2.1.2 C1 编译器主要优化手段](JIT%20和%20AOT.md#2.1.2%20C1%20编译器主要优化手段)

**2、平台依赖性**

>AOT 编译通常会生成特定平台的机器码：在 Linux 上编译出的本地代码只能在 Linux 环境下运行，在 Windows 上编译出的本地代码只能在 Windows 上运行

**3、AOT 编译的前期成本**

>AOT 编译的前期成本较高，对于大规模应用编译的时间可能非常长，生成的本地代码文件通常比较大，可能导致部署和存储成本增加，而JIT 编译可以在运行时按需编译，避免了这种前期成本，程序可以边启动边优化

**4、适用于特定场景，非通用**

>AOT 编译非常适合那些启动时间敏感、运行时行为比较固定的应用，如容器化部署、微服务等；对于一些需要长时间运行、且在运行过程中有大量动态行为的应用则更适合使用 JIT 编译

**5、JVM 本身的内存管理**

>JVM 通过垃圾回收机制来管理内存，这一机制需要在运行时根据实际使用情况进行调整，AOT 编译的程序如果没有考虑 GC 的动态调整，可能会导致内存管理不够灵活

