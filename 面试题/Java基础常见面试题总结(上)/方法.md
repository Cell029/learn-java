
# 1. 什么是静态方法的返回值？方法有哪几种类型？

[方法](../../java笔记/方法.md#^129fde)

****
# 2. 静态方法为什么不能调用非静态成员

[方法](../../java笔记/方法.md#^bae8ff)

****
# 3. 静态方法与实例方法有何不同？

| 对比维度          | 静态方法（static method）                           | 实例方法（instance method）                       |
| ------------- | --------------------------------------------- | ------------------------------------------- |
| **所属对象**      | 属于类本身                                         | 属于类的对象（实例）                                  |
| **调用方式**      | 类名.方法() 或 对象.方法()（推荐用类名调用）                    | 需要通过对象调用：对象.方法()                            |
| **是否依赖对象**    | 不依赖对象，可在未创建对象时调用                              | 依赖对象，必须创建对象后调用                              |
| **内存位置**      | 方法区（随类加载即存在）                                  | 堆内存中，依赖对象的创建                                |
| **访问权限**      | 只能访问静态成员（变量/方法）                               | 可访问所有成员（包括静态和实例）                            |
| **是否可用 this** | 不可使用 `this`                                   | 可以使用 `this`                                 |
| **典型应用场景**    | 工具方法（如 Math、Collections），全局状态管理               | 与对象状态有关的行为或业务逻辑                             |
| **是否可重写**     | 不能被重写，只能被“隐藏”[多态](../../java笔记/多态.md#^e66367) | 支持方法重写                                      |
| **接口支持情况**    | Java 8+ 可定义静态方法（只能通过接口名调用）                    | 接口中常规默认方法为实例方法                              |
| **常见使用例子**    | `Math.pow()`, `Arrays.sort()`                 | `toString()`, `equals()`, `getName()` 等对象方法 |

****
# 4. 重载和重写有什么区别

[[../../java笔记/多态.md|多态]]

| 对比维度            | 方法重载（Overload）      | 方法重写（Override）                                              |
| --------------- | ------------------- | ----------------------------------------------------------- |
| **定义位置**        | 同一个类中               | 父类与子类之间                                                     |
| **参数列表**        | 必须不同（类型、个数或顺序不同）    | 必须完全相同（名称和参数）                                               |
| **返回类型**        | 可以相同或不同，但不能仅靠返回类型区分 | 必须相同，或是父类返回类型的子类类型（协变返回类型 [多态](../../java笔记/多态.md#^d5ae92)） |
| **访问修饰符（访问权限）** | 没有限制                | 子类不能缩小父类的访问权限（如 public → private ），但可以更大                    |
| **异常处理**        | 无限制                 | 子类抛出的受检异常必须是父类的相同或更窄子类                                      |
| **是否支持多态**      | 不支持（编译期绑定）          | 支持（运行期绑定，实现多态）                                              |
| **绑定时机**        | 编译时（静态绑定）           | 运行时（动态绑定）                                                   |
| **用途**          | 实现同功能不同方式的调用，提高灵活性  | 修改或扩展父类/接口中的行为，体现“行为多态”                                     |

****
# 5. 什么是可变长参数

>从 Java5 开始，Java 支持定义可变长参数，所谓可变长参数就是允许在调用方法时传入不定长度的参数，就比如下面这个方法就可以接受 0 个或者多个参数

```java
public static void method1(String... args) {
   //......
}
```

```java
public static int sum(int... numbers) {
    int total = 0;
    for (int num : numbers) {
        total += num;
    }
    return total;
}
public static void main(String[] args) {
    System.out.println(sum()); // 0
    System.out.println(sum(1)); // 1
    System.out.println(sum(1, 2, 3, 4, 5)); // 15
}
```

>另外，可变参数只能作为函数的最后一个参数，但其前面可以有也可以没有任何其他参数

```java
public static void method2(String arg1, String... args) {
   //......
}
```

>遇到方法重载会优先匹配固定参数的方法，但如果使用了可变长参数那就会调用可变参数方法了

```java
void test(int a, int b) {
    System.out.println("固定参数方法");
}

void test(int... nums) {
    System.out.println("可变参数方法");
}

public static void main(String[] args) {
    OverloadTest ot = new OverloadTest();
    ot.test(10, 20); // 固定参数方法
}
```

****

