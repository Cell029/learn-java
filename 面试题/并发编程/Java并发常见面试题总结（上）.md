
# 1. 什么是线程和进程

[进程](多线程.md#2.1%20进程)

[线程](多线程.md#2.2%20线程)

****
# 2. Java 线程和操作系统的线程有什么区别

Java 线程是 JVM（Java 虚拟机）中对线程的抽象表示，通过 `java.lang.Thread` 类来创建和管理线程，运行时依赖 JVM 的实现和操作系统的调度机制。

操作系统线程是由操作系统内核调度和管理的线程，每个线程由内核分配资源（如堆栈、寄存器）并进行调度，是 CPU 实际运行和调度的最小单位。

现代 JVM 中，Java 线程通常是一对一映射到 OS 线程的，每创建一个 Java 线程，JVM 就通过本地方法（如 pthreads）创建一个 OS 线程，JVM 依赖操作系统来进行调度。假设在 Java 中创建了 10 个线程，那么操作系统层面也会创建 10 个真实的内核线程，由 OS 调度运行。

|对比维度|Java 线程|操作系统线程|
|---|---|---|
|所属层级|Java 应用层（JVM）|操作系统内核|
|管理者|JVM 管理（Thread API）|OS 内核调度器|
|创建方式|`new Thread()`、`Executors`|系统调用（如 `pthread_create`）|
|调度机制|依赖 OS 线程调度|由内核根据调度算法决定（如时间片）|
|资源分配|JVM 为线程分配栈帧、局部变量表等|OS 分配线程堆栈、寄存器等|
|性能成本|创建开销较小（抽象层）|创建和切换成本较高|
|数量限制|JVM 参数限制（如 `-Xss`）、堆内存|OS 限制（进程资源、线程栈）|

****
# 3. 进程与线程的关系、区别及优缺点

[进程和线程的区别](多线程.md#2.3%20进程和线程的区别)

****
# 4.  如何创建线程

[线程的实现方式](多线程.md#4.%20​%20线程的实现方式)

****
# 5. 线程的生命周期和状态

[生命周期的七大状态](多线程.md#5.%20生命周期的七大状态)

****
# 6. 什么是线程上下文切换

线程在执行过程中会有自己的运行条件和状态（也称上下文），比如程序计数器、栈信息等。当出现如下情况的时候，线程会从占用 CPU 状态中退出：

- 主动让出 CPU，比如调用了 `sleep()`, `wait()` 等。
- 时间片用完，因为操作系统要防止一个线程或者进程长时间占用 CPU 导致其他线程或者进程饿死。
- 调用了阻塞类型的系统中断，比如请求 IO，线程被阻塞。
- 被终止或结束运行

线程切换意味着需要保存当前线程的上下文，程序计数器是一个专用的寄存器，用于表明指令序列中 CPU 正在执行的位置，存的值为正在执行的指令的位置或者下一个将要被执行的指令的位置，具体依赖于特定的系统，它就是用来保证线程下次占用 CPU 的时候恢复现场，并加载下一个将要占用 CPU 的线程上下文，这就是所谓的上下文切换。

上下文切换是现代操作系统的基本功能，因其每次需要保存信息恢复信息，这将会占用 CPU，内存等系统资源进行处理，也就意味着效率会有一定损耗，如果频繁切换就会造成整体效率低下。

****
# 7. Thread#sleep() 和 Object#wait()

[Thread#sleep() 和 Object#wait() 对比](多线程.md#6.6%20Thread%20sleep()%20和%20Object%20wait()%20对比)

****
# 8. 为什么 wait() 不定义在 Thread 中

`wait()` 是让获得对象锁的线程实现等待，会自动释放当前线程占有的对象锁。每个对象（`Object`）都拥有对象锁，既然要释放当前线程占有的对象锁并让其进入 WAITING 状态，自然是要操作对应的对象（`Object`）而非当前的线程（`Thread`）。

类似的问题：为什么 `sleep()` 方法定义在 `Thread` 中？

因为 `sleep()` 是让当前线程暂停执行，不涉及到对象类，也不需要获得对象锁。

****
# 9. 可以直接调用 Thread 类的 run() 吗

new 一个 `Thread`，线程进入了新建状态，调用 `start()` 方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 `start()` 会执行线程的相应准备工作，然后自动执行 `run()` 方法的内容，这是真正的多线程工作。直接调用 `Thread` 类的 `run()` 方法，这样不会创建一个新的线程，`run()` 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。

****
# 10. 并发与并行的区别

[并发和并行](多线程.md#1.%20并发和并行)

****
# 11. 同步和异步的区别

- 同步：等待任务完成之后再继续执行后续操作。  
- 异步：任务开始后，不等其完成，立即继续执行后续操作，任务完成后再通过回调、事件等通知结果。

****
# 12. 为什么使用多线程

- **从计算机底层来说：** 线程可以比作是轻量级的进程，是程序执行的最小单位，线程间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。
- **从当代互联网发展趋势来说：** 现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。
- **单核时代**：在单核时代多线程主要是为了提高单进程利用 CPU 和 IO 系统的效率。 假设只运行了一个 Java 进程的情况，请求 IO 的时候，如果此线程被 IO 阻塞则整个进程被阻塞。CPU 和 IO 设备只有一个在运行，那么可以简单地说系统整体效率只有 50%。当使用多线程的时候，一个线程被 IO 阻塞，其他线程还可以继续使用 CPU，从而提高 Java 进程利用系统资源的整体效率。
- **多核时代**：多核时代多线程主要是为了提高进程利用多核 CPU 的能力。举个例子：假如要计算一个复杂的任务，只用一个线程的话，不论系统有几个 CPU 核心，都只会有一个 CPU 核心被利用到。而创建多个线程，这些线程可以被映射到底层多个 CPU 核心上执行，在任务中的多个线程没有资源竞争的情况下，任务执行的效率会有显著性的提高，约等于（单核时执行时间/CPU 核心数）。

****
# 13. 单核 CPU 支持多线程吗

单核 CPU 是支持 Java 多线程的，只不过是操作系统通过时间片轮转的方式，将 CPU 的时间分配给不同的线程。尽管单核 CPU 一次只能执行一个任务，但通过快速在多个线程之间切换，可以让用户感觉多个任务是同时进行的。操作系统主要通过两种线程调度方式来管理多线程的执行：

- **抢占式调度（Preemptive Scheduling）**：操作系统决定何时暂停当前正在运行的线程，并切换到另一个线程执行。这种切换通常是由系统时钟中断（时间片轮转）或其他高优先级事件（如 I/O 操作完成）触发的。这种方式存在上下文切换开销，但公平性和 CPU 资源利用率较好，不易阻塞。
- **协同式调度（Cooperative Scheduling）**：当前线程自己决定何时让出 CPU，运行完毕后会主动通知系统切换到另一个线程。这种方式可以减少上下文切换带来的性能开销，但公平性较差，并且如果一个线程死循环，会导致系统阻塞。

Java 使用的线程调度是抢占式的，也就是说 JVM 本身不负责线程的调度，而是将线程的调度委托给操作系统。操作系统通常会基于线程优先级和时间片来调度线程的执行，高优先级的线程通常获得 CPU 时间片的机会更多。

****
# 14. 单核 CPU 上运行多个线程效率一定高吗

单核 CPU 同时运行多个线程的效率是否会高，取决于线程的类型和任务的性质。一般来说，有两种类型的线程：

- **CPU 密集型**：CPU 密集型的线程主要进行计算和逻辑处理，需要占用大量的 CPU 资源。
- **IO 密集型**：IO 密集型的线程主要进行输入输出操作，如读写文件、网络通信等，需要等待 IO 设备的响应，而不占用太多的 CPU 资源。

在单核 CPU 上，同一时刻只能有一个线程在运行，其他线程需要等待 CPU 的时间片分配。如果线程是 CPU 密集型的，那么多个线程同时运行会导致频繁的线程切换，增加了系统的开销，降低了效率。如果线程是 IO 密集型的，CPU 在 I/O 等待时可切换线程执行其他任务，提高利用率。因此，对于单核 CPU 来说，如果任务是 CPU 密集型的，那么开很多线程会影响效率；如果任务是 IO 密集型的，那么开很多线程会提高效率。当然，这里的“很多”也要适度，不能超过系统能够承受的上限。

| 任务类型    | 是否适合多线程（单核） | 原因说明                           |
| ------- | ----------- | ------------------------------ |
| I/O 密集型 | 是           | CPU 在 I/O 等待时可切换线程执行其他任务，提高利用率 |
| CPU 密集型 | 否           | 多线程只会带来上下文切换开销，反而拖慢执行速度        |
| 高锁竞争任务  | 否           | 多线程造成频繁加锁/阻塞，效率反而降低            |
| 响应性任务   | 是           | 能保持界面/服务的流畅性，尽管总执行时间未必更快       |

****
# 15. 使用多线程可能带来什么问题

1、线程安全问题（数据不一致）

[线程安全问题](多线程.md#11.%20线程安全问题)

2、死锁（Deadlock）

[死锁](多线程.md#14.%20死锁)

3、活锁（Livelock）

线程虽然不会被阻塞，但持续重复做某件事让程序无法前进（即循环等待）。例如：两个线程同时检测对方是否“让路”，结果互相谦让，谁也不执行实际任务，表现为程序一直在运行，但没有进展。

4、线程饥饿（Starvation）

某些线程长期无法获得资源或执行权，被其他高优先级线程持续“压制”。原因可能包括：

- 锁被高优先级线程频繁抢占
- 使用了不公平的锁机制（如默认的 `ReentrantLock`）
- 使用线程池时，核心线程占满任务队列，某些任务被长期排队

5、上下文切换开销大

线程之间频繁切换（调度器让出 CPU），每次切换都涉及保存和恢复线程状态、缓存失效等，严重影响性能。

****
# 16. 如何理解线程安全和不安全

[线程安全问题](多线程.md#11.%20线程安全问题)

****
# 17. 什么是线程死锁

[死锁](多线程.md#14.%20死锁)

****
# 18. 如何检测死锁

1、使用 JDK 提供的命令行工具

- **jps**：查看当前运行的 Java 进程
- **jstack**：打印线程堆栈信息，查看是否有死锁

```java
jps
19504 Main
2456 Jps
```

```java
jstack 19504
```

如果存在死锁，一般会输出下面类似的内容：

```text
Found one Java-level deadlock:
=============================
"Thread-1":
  waiting to lock monitor 0x00007fa8a4001038 (object 0x00000000d5a9ec10, a java.lang.Object),
  which is held by "Thread-2"
"Thread-2":
  waiting to lock monitor 0x00007fa8a4001068 (object 0x00000000d5a9ec20, a java.lang.Object),
  which is held by "Thread-1"

Java stack information for the threads listed above:
...
```

2、使用图形化工具

- JConsole（JDK 自带）
	1. 运行程序后打开终端输入 `jconsole`；
	2. 连接对应的 Java 应用；
	3. 点击线程（Threads）选项卡；
	4. 查看是否有 `deadlock` 相关信息。
- VisualVM
	1. 下载 VisualVM；
	2. 连接本地 Java 应用；
	3. 打开 Threads 标签页；
	4. 若存在死锁，会高亮显示并提供堆栈信息。

****
# 19. 如何预防和避免死锁

[死锁预防](多线程.md#14.2%20死锁预防)

****
