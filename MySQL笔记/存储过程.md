
>MySQL 的存储过程（Stored Procedure）是一组预编译好并保存在数据库中的 SQL 语句集合，可以带参数，在需要时通过调用执行，将代码抽象为方法，当之后需要使用时，不需要再重写一遍代码，而是直接根据名称调用相应的方法即可

# 1. 概述

>常规的`SQL`语句在执行时需要先经过编译、分析、优化等过程，最后再执行，而存储过程则不需要，一般存储过程都是预先已经编译过的

### 优点

1、复用性

>存储过程创建一次后便可多次调用，对于数据库结构的变更，只需要修改数据库中的存储过程，无需修改业务代码，这也就意味着不会影响到调用它的应用程序源代码

2、灵活性

>可使用流程控制语句（如 `IF...ELSE`、`WHILE`、`LOOP`），也可定义局部变量、游标，适合复杂计算

3、省资源

>普通的`SQL`一般都会存储在客户端，如 Java 中的 `dao/mapper` 层，每次执行`SQL`需要通过网络将`SQL`语句发送给数据库执行，而存储过程是保存在`MySQL`中的，因此当客户端调用存储过程时，只需要通过网络传送存储过程的调用语句和参数，无需将 `SQL` 语句通过网络传输，从而降低网络负载

4、性能高

>存储过程执行多次后，会将 `SQL` 语句编译成机器码驻留在线程缓冲区，在以后的调用中，只需要从缓冲区中执行机器码即可，无需再次编译执行，从而提高了系统的效率和性能

5、安全性

>对于不同的存储过程，可根据权限设置执行的用户，因此对于一些特殊的 `SQL`，例如清空表这类操作，可以设定 `root、admin` 用户才可执行；同时由于存储过程编写好之后，对于客户端而言是看不见的，因此减小了 `SQL` 被暴露的风险

****
### 缺点

1、CPU 开销大

>MySQL 的核心职责是数据的存储和检索，而不是复杂的业务逻辑计算，存储过程本质上是运行在 MySQL 线程中的脚本，但它无法充分利用多核并发优化，所以对于大量分支判断、循环、临时数据处理等任务，就会造成会 MySQL 单线程处理压力极大，从而影响业务的执行效率

2、内存占用高

>每一个 MySQL 连接（线程）都有自己的内存空间，当一个数据库连接反复调用某个存储过程后，MySQL 会直接将该存储过程的机器码放入到连接的内存空间，当 MySQL 中的大量连接都在频繁调用存储过程时，必然会导致内存占用率飙升

3、维护性差

>一方面是过于复杂的存储过程，毕竟存储过程类似于一门新的语言，不同语言之间跨度较大。另一方面是很少有数据库的存储过程支持 `Debug` 调试，MySQL 的存储过程就不支持，这也就意味着`Bug`出现时，无法像应用程序那样正常调试排查，必须得采取人肉排查模式，即一步步拆解存储过程并排查

****
# 2. 存储过程的语法

```sql
DELIMITER $

CREATE -- 创建的语法
	PROCEDURE 存储过程名 ([IN|OUT|INOUT] 参数名 数据类型, ...)
BEGIN
    -- 存储过程体
END$$

DELIMITER ;
```

`SQL` 的存储过程与方法一样，同样也支持四种定义，主要依赖于 `IN`、`OUT`、`INOUT` 三个关键字来区分：

- 定义存储过程时，没有入参也没有出参，代表无参无返回类型
- 定义存储过程时，仅定义了带有 `IN` 类型的参数，表示有参无返回类型
- 定义存储过程时，仅定义了带有 `OUT` 类型的参数，表示无参有返回类型
- 定义存储过程时，同时定义了带有 `IN`、`OUT` 类型的参数，或定义了带有 `INOUT` 类型的参数，表示有参有返回类型

`DELIMITER $` 干什么的？

>它表示指定结束标识，在 `MySQL` 中默认是以 `;` 分号作为一条语句的结束标识，如果在存储过程的过程体中包含了`SQL`语句，并且 `SQL` 语句以`;`结束时，MySQL 会认为存储过程的定义也结束了，过程体就会和 `;` 结束符冲突，所以一般需要要重新定义结束符，例如 `DELIMITER $`，表示以 `$` 作为结束标识，只有当 MySQL 识别到 `$` 符时，才会认为结束了

但在结束之后，要再次把结束符改回 `;` ，即 `DELIMITER ;` 

存储过程体中可以指定存储过程的约束条件，取值范围有很多（但通常使用默认的），如下：

1、`LANGUAGE SQL`

>说明存储过程中的过程体是否由 `SQL` 语句组成

2、`[NOT] DETERMINISTIC`

>说明存储过程的返回值是否为固定的，没有`[NOT]`表示为固定的，默认为非固定的

3、`{ CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA }`

>说明过程体使用`SQL`语句的限制：

- `CONTAINS SQL`：表示当前存储过程包含 `SQL` ，但不包含读写数据的 `SQL` 语句
- `NO SQL`：表示当前存储过程中不包含任何 `SQL` 语句
- `READS SQL DATA`：表示当前存储过程中包含读数据的 `SQL` 语句
- `MODIFIES SQL DATA`：表示当前存储过程中包含写数据的 `SQL` 语句

4、`SQL SECURITY { DEFINER | INVOKER }`

>说明哪些用户可以调用当前创建的存储过程：

- `DEFINER`：表示只有定义当前存储过程的用户才能调用
- `INVOKER`：表示任何具备访问权限的用户都能调用

5、`COMMENT '....'`

>注释信息，可以用来描述当前创建的存储过程

****
## 2.1 存储过程的定义

### 1. 查询用户表的所有用户信息

```sql
DELIMITER $

CREATE 
    -- 定义存储过程的名称为：get_all_userInfo()
    PROCEDURE get_all_userInfo()
BEGIN
    -- 存储过程体：由一条查询全表的 SQL 组成
    select * from `users`;
    
END $

DELIMITER ;
```

![](images/存储过程/file-20250521194732.png)

```sql
CALL get_all_userInfo();
```

>所有存储过程都是通过`CALL`命令来调用

![](images/存储过程/file-20250521194821.png)

****
### 2. 接收一个用户名，查询用户的注册时间







