
>MySQL 的存储过程（Stored Procedure）是一组预编译好并保存在数据库中的 SQL 语句集合，可以带参数，在需要时通过调用执行，将代码抽象为方法，当之后需要使用时，不需要再重写一遍代码，而是直接根据名称调用相应的方法即可

# 1. 概述

>常规的`SQL`语句在执行时需要先经过编译、分析、优化等过程，最后再执行，而存储过程则不需要，一般存储过程都是预先已经编译过的

### 优点

1、复用性

>存储过程创建一次后便可多次调用，对于数据库结构的变更，只需要修改数据库中的存储过程，无需修改业务代码，这也就意味着不会影响到调用它的应用程序源代码

2、灵活性

>可使用流程控制语句（如 `IF...ELSE`、`WHILE`、`LOOP`），也可定义局部变量、游标，适合复杂计算

3、省资源

>普通的`SQL`一般都会存储在客户端，如 Java 中的 `dao/mapper` 层，每次执行`SQL`需要通过网络将`SQL`语句发送给数据库执行，而存储过程是保存在`MySQL`中的，因此当客户端调用存储过程时，只需要通过网络传送存储过程的调用语句和参数，无需将 `SQL` 语句通过网络传输，从而降低网络负载

4、性能高

>存储过程执行多次后，会将 `SQL` 语句编译成机器码驻留在线程缓冲区，在以后的调用中，只需要从缓冲区中执行机器码即可，无需再次编译执行，从而提高了系统的效率和性能

5、安全性

>对于不同的存储过程，可根据权限设置执行的用户，因此对于一些特殊的 `SQL`，例如清空表这类操作，可以设定 `root、admin` 用户才可执行；同时由于存储过程编写好之后，对于客户端而言是看不见的，因此减小了 `SQL` 被暴露的风险

****
### 缺点

1、CPU 开销大

>MySQL 的核心职责是数据的存储和检索，而不是复杂的业务逻辑计算，存储过程本质上是运行在 MySQL 线程中的脚本，但它无法充分利用多核并发优化，所以对于大量分支判断、循环、临时数据处理等任务，就会造成会 MySQL 单线程处理压力极大，从而影响业务的执行效率

2、内存占用高

>每一个 MySQL 连接（线程）都有自己的内存空间，当一个数据库连接反复调用某个存储过程后，MySQL 会直接将该存储过程的机器码放入到连接的内存空间，当 MySQL 中的大量连接都在频繁调用存储过程时，必然会导致内存占用率飙升

3、维护性差

>一方面是过于复杂的存储过程，毕竟存储过程类似于一门新的语言，不同语言之间跨度较大。另一方面是很少有数据库的存储过程支持 `Debug` 调试，MySQL 的存储过程就不支持，这也就意味着`Bug`出现时，无法像应用程序那样正常调试排查，必须得采取人肉排查模式，即一步步拆解存储过程并排查

****
# 2. 存储过程的语法

```sql
DELIMITER $

CREATE -- 创建的语法
	PROCEDURE 存储过程名 ([IN|OUT|INOUT] 参数名 数据类型, ...)
BEGIN
    -- 存储过程体
END$$

DELIMITER ;
```

`SQL` 的存储过程与方法一样，同样也支持四种定义，主要依赖于 `IN`、`OUT`、`INOUT` 三个关键字来区分：

- 定义存储过程时，没有入参也没有出参，代表无参无返回类型
- 定义存储过程时，仅定义了带有 `IN` 类型的参数，表示有参无返回类型
- 定义存储过程时，仅定义了带有 `OUT` 类型的参数，表示无参有返回类型
- 定义存储过程时，同时定义了带有 `IN`、`OUT` 类型的参数，或定义了带有 `INOUT` 类型的参数，表示有参有返回类型

`DELIMITER $` 干什么的？

>它表示指定结束标识，在 `MySQL` 中默认是以 `;` 分号作为一条语句的结束标识，如果在存储过程的过程体中包含了`SQL`语句，并且 `SQL` 语句以`;`结束时，MySQL 会认为存储过程的定义也结束了，过程体就会和 `;` 结束符冲突，所以一般需要要重新定义结束符，例如 `DELIMITER $`，表示以 `$` 作为结束标识，只有当 MySQL 识别到 `$` 符时，才会认为结束了

但在结束之后，要再次把结束符改回 `;` ，即 `DELIMITER ;` 

存储过程体中可以指定存储过程的约束条件，取值范围有很多（但通常使用默认的），如下：

1、`LANGUAGE SQL`

>说明存储过程中的过程体是否由 `SQL` 语句组成

2、`[NOT] DETERMINISTIC`

>说明存储过程的返回值是否为固定的，没有`[NOT]`表示为固定的，默认为非固定的

3、`{ CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA }`

>说明过程体使用`SQL`语句的限制：

- `CONTAINS SQL`：表示当前存储过程包含 `SQL` ，但不包含读写数据的 `SQL` 语句
- `NO SQL`：表示当前存储过程中不包含任何 `SQL` 语句
- `READS SQL DATA`：表示当前存储过程中包含读数据的 `SQL` 语句
- `MODIFIES SQL DATA`：表示当前存储过程中包含写数据的 `SQL` 语句

4、`SQL SECURITY { DEFINER | INVOKER }`

>说明哪些用户可以调用当前创建的存储过程：

- `DEFINER`：表示只有定义当前存储过程的用户才能调用
- `INVOKER`：表示任何具备访问权限的用户都能调用

5、`COMMENT '....'`

>注释信息，可以用来描述当前创建的存储过程

****
## 2.1 存储过程的定义

| user_id | user_name | user_sex | password | register_time        |
|---------|-----------|----------|----------|---------------------|
| 1       | 熊猫      | 女       | 6666     | 2025-07-05 09:15:22 |
| 2       | 竹子      | 男       | 1234     | 2025-08-12 14:33:47 |
| 3       | 子竹      | 男       | 4321     | 2025-09-01 11:25:18 |
| 4       | 黑熊      | 男       | 8888     | 2025-10-03 16:42:55 |
| 8       | 猫熊      | 女       | 8888     | 2025-10-15 08:07:31 |

### 1. 查询用户表的所有用户信息

```sql
DELIMITER $

CREATE 
    -- 定义存储过程的名称为：get_all_userInfo()
    PROCEDURE get_all_userInfo()
BEGIN
    -- 存储过程体：由一条查询全表的 SQL 组成
    select * from `users`;
    
END $

DELIMITER ;
```

![](images/存储过程/file-20250521194732.png)

```sql
CALL get_all_userInfo();
```

>所有存储过程都是通过`CALL`命令来调用

![](images/存储过程/file-20250521194821.png)

****
### 2. 接收一个用户名，查询用户的注册时间

```sql
DELIMITER $

CREATE 
    -- 在定义存储过程时，用 IN 声明了一个入参
    PROCEDURE get_user_register_time(IN name varchar(255))
BEGIN
    select register_time from `users` where user_name = name;
END $

DELIMITER ;
```

```sql
CALL get_user_register_time("竹子");
```

![](images/存储过程/file-20250521195257.png)

>在定义带有参数的存储过程时要注意：参数名必须在参数类型的前面，同时参数类型需要定义长度，也就是 `varchar(255)` ，而并非 `varchar` ，否则低版本的 `MySQL` 会出现不兼容的问题

****
### 3. 查询 `ID=1` 的用户密码并返回

```sql
DELIMITER $

CREATE 
    -- 在定义存储过程时，用 OUT 声明了一个返回值
    PROCEDURE get_user_password(OUT userPassword varchar(255))
BEGIN
    select password into userPassword from `users` where user_id = 1;
END $

DELIMITER ;
```

```sql
CALL get_user_password(@userPassword);
select @userPassword;
```

![](images/存储过程/file-20250521195954.png)

>调用一个带 `OUT` 参数的存储过程时，需要提供一个用于接收返回值的“用户变量”，也就是 `@变量名` ，所以存储过程运行后，会把查出的 `password` 赋值给 `userPassword` ，这个值通过 OUT 机制传回到传进去的 `@userPassword` ，后续通过 `select` 查询

****
### 4. 接收一个用户名，返回该用户名对应的用户 ID

```sql
DELIMITER $

CREATE 
    -- 在定义存储过程时，用 OUT 声明了一个返回值
    PROCEDURE get_user_id(INOUT parameters varchar(255))
BEGIN
    select user_id into parameters from `users` where user_name = parameters;
END $

DELIMITER ;

-- 等价于
PROCEDURE get_user_id(IN userName varchar(255), OUT userId INT)
BEGIN
    SELECT user_id INTO userId FROM zz_users WHERE user_name = userName;
END

```

>上述存储过程中，利用 `INOUT` 定义了一个参数 `parameters` ，在存储过程体当中，使用它作为查询参数，也使用它作为保存返回值的变量

```sql
-- 定义一个变量
set @parameters = "熊猫";
-- 将定义的变量传入
CALL get_user_id(@parameters);
-- 查询定义的变量
select @parameters;

-- 等价于
SET @name = '熊猫';
CALL get_user_id(@name, @id);
SELECT @id;
```

![](images/存储过程/file-20250521201307.png)

>存储过程中的返回值并不像 Java 语言中的 `return` ，而是通过变量传递的方式来实现

****
## 2.2 系统变量、用户变量和局部变量

##### 系统变量

>在 MySQL 启动后，其内部也会存在许多的系统变量，系统的意思是指由 MySQL 定义的，而并非用户自己定义的，一般系统变量要么来自于 MySQL 编译期，要么来自于 `my.ini` 配置文件

查看系统变量：

```sql
-- 查看所有系统变量
SHOW VARIABLES;

-- 查看全局变量
SELECT @@global.xxx;

-- 查看当前会话变量
SELECT @@session.xxx;
```

![](images/存储过程/file-20250521202536.png)

修改变量：

```sql
-- 修改全局变量（需管理员权限）
SET GLOBAL max_connections = 300;

-- 修改当前会话变量
SET SESSION sql_mode = 'STRICT_ALL_TABLES'; -- 启用严格模式对所有表的严格数据校验
```

>全局变量的修改**不会影响已经建立的连接**，只有新连接才会生效

****
##### 用户变量

>用户变量是自定义的变量，通常用于存储临时值，用于多条 SQL 语句之间共享数据

定义与赋值：

```sql
-- 使用等号赋值
SET @变量名 = '变量值';

-- 使用 := 赋值
SET @age := 20;

-- 在 SELECT 中赋值
SELECT @count := COUNT(*) FROM students;
```

查询变量：

```sql
SELECT @name, @age;
```

>变量名以 `@` 开头，不需要声明数据类型，只在当前会话中有效，断开连接后自动销毁

****
##### 局部变量

>局部变量是在存储过程或函数中定义的变量，仅在该过程或函数的 `BEGIN...END` 块内可见，类似于方法中的定义的变量

必须使用 `DECLARE` 语句，并在过程体内最前面声明：

```sql
DECLARE 变量名 数据类型 DEFAULT 默认值;

DECLARE message varchar(255) default "not message";
```

赋值方式：

```sql
-- 赋值方式一
SET message = 变量值;
SET message := 变量值;

-- 赋值方式二
select 字段名或函数 into message from 表名;
```

```sql
DELIMITER $

CREATE 
    -- 定义了一个 求两数之和 的存储过程
    PROCEDURE add_value(IN number1 int(8), OUT result int(8))
BEGIN
    -- 这里定义了一个局部变量：number2，默认值为 666
    DECLARE number2 int(8) default 666;
    -- 将两个数字相加，计算得到的和放入用户变量 result 中
    SET result := number1 + number2;
END $

DELIMITER ;

-- 定义一个用户变量，接收调用存储过程后得到的和
SET @result = 0;
-- 调用存储过程，传入一个数字 888 以及接收结果的 result 变量
CALL add_value(888,@result);
-- 查询计算后的和
SELECT @result;
```

****
## 2.3 流程控制 - IF 判断与 CASE 分支

### 1. 条件判断：IF

```sql
IF 条件判断 THEN
    -- 分支操作.....
ELSEIF 条件判断 THEN
    -- 分支操作.....
ELSE
    -- 分支操作.....
END IF
```

- `IF ... THEN`（必需）
- `ELSEIF ... THEN`（可选，可多个）
- `ELSE`（可选）

```sql
DELIMITER $

CREATE 
    PROCEDURE if_user_age(IN age int, OUT msg varchar(255))
BEGIN		
    IF age < 18 THEN
        SET msg := '未成年';
    ELSEIF age = 18 THEN
        SET msg := '刚成年';
    ELSE
        SET msg := '已成年';
		END IF;
		
END $

DELIMITER ;

SET @msg := "Not Data"; 
CALL if_user_age(16,@msg); 
SELECT @msg; -- 未成年

CALL if_user_age(18,@msg); 
SELECT @msg; -- 刚成年

CALL if_user_age(25,@msg); 
SELECT @msg; -- 已成年
```

****
### 2. 分支判断：CASE

CASE 类似于 Java 中的 switch


