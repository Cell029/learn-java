
# 1. B 树（二三树）

>B 树（Balanced Tree，多路平衡查找树）是一种多叉树（不像二叉树每个节点只有两个孩子），它的节点可以有多个孩子

假设 B 树是一个 M 阶 B 树，那么：

- 每个节点最多有 `M` 个子节点
- 每个节点至少有 `⌈M/2⌉` 个子节点（根节点除外）
- 每个内部节点最多有 `M-1` 个键值
- 所有叶子节点在同一层，即树高保持平衡
- 所有键值在节点中按升序排列
- 每个键值用于分隔不同子树的范围

```less
        [17 | 35]
      /     |     \
 [10]    [20|25]    [40|50] 
```

>因为 B 树的特性，在相同的数据量的情况下，它比二叉树更矮，而每经过一层树就需要一次 IO 操作，所以 B 树可用有效地减少 IO 操作次数，提高效率

****
# 2. B+ 树

>B+ 树是在 B 树的基础上演化出来的一种多路平衡查找树，是数据库索引最常用的结构。B+ 树中的非叶子节点都不存储数据，而是只作为索引（划分范围），由叶子节点存放整棵树的所有数据，所以整体的高度不会很高，所以查询速度很快。而叶子节点之间构成一个从小到大有序的链表互相指向相邻的叶子节点，也就是叶子节点之间形成了有序的双向链表。

![](images/B+%20树索引/file-20250522195021.png)

插入与删除：

>B+ 树做了大量冗余节点，父节点的所有元素都会在子节点中出现，当删除一个节点时，可以直接从叶子节点中删除，只需要调整叶子节点，平衡操作效率更高，插入操作类似，最多只涉及树的一条分支路径

****
# 3. MySQL 索引为什么使用 B+ 树结构？

## 普通 SQL 的全表扫描过程

![](images/B+%20树索引/file-20250522203937.png)

>在 MySQL 的 InnoDB 存储引擎中，数据是按页为单位进行管理和读写的，每页大小默认为 16KB，可以存放多条记录（具体数量取决于每条记录的大小）

当执行 `select * from users where name = '熊猫'` 时，如果没有使用索引（全表扫描），InnoDB 会从磁盘读取一个或多个页到内存中进行判断。而 MySQL 会使用局部性原理，所以它并不会一次只读取一条记录，而是一次性将一整个数据页读入内存，即使“熊猫”是第五条记录，只要它和前四条记录位于同一个数据页中，也只需一次 IO 操作即可获取到它所在的记录块

然后会继续进行下一次 IO 操作读取更多页，直到整张表扫描完毕为止，所有符合条件的记录会被临时保存在内存中的结果集中，最后一并返回给客户端（因为表中的字段没有建立唯一索引或唯一约束，因此 MySQL 不确定是否还有其他同名的数据，所以需要将整个表全部扫描一遍，才能得到最终结论）

>根据以上结果可以看出，当表的数据非常庞大时，一次全表扫描可能会触发非常多次的 IO 操作，这会导致开销十分大，为了避免全表扫描，就引入了索引机制

****
## 3.2 索引为什么不选二叉树？

>二叉树搜索是基于二分搜索法实现的一种数据结构，在理想情况下是平衡的，高度为 `log₂N`（N 是节点数），但在最坏情况下树的结构可能成为一条线，此时退化成单链表，高度变为 `N`，搜索效率变为 O(N)，会让 IO 操作变多，并且此时和全表扫描没有什么差异

****
## 3.3 索引为什么不用红黑树

>红黑树是一种自平衡的二叉树，它不会退化成单链表的情况，但是它的节点只能存储一个数据，并且自平衡的特性会导致节点中存储的数据不连续，这样就无法利用局部性原理，随着数据的增多，IO 次数并不会得到明显的降低

****
## 3.4 索引为什么不用 B 树

>在 B 树中，每个节点会存储关键字和数据，但数据通常比索引 key 更大，这就导致单个节点能容纳的关键字数量变少，而这就会导致树变高

假设一个磁盘页 16KB，一个 key 8 字节，一个数据行 200 字节：

>如果节点只存 key，能容纳约 2000 个 key，如果每个 key 携带一条数据，只能容纳 70 多个键值对，树的高度差别会非常明显，而数据又分布在所有节点中，数据结构零散，不利于使用局部性原理，所以任然不能有效降低 IO 次数

****
#








