
# 1. B 树（二三树）

>B 树（Balanced Tree，多路平衡查找树）是一种多叉树（不像二叉树每个节点只有两个孩子），它的节点可以有多个孩子

假设 B 树是一个 M 阶 B 树，那么：

- 每个节点最多有 `M` 个子节点
- 每个节点至少有 `⌈M/2⌉` 个子节点（根节点除外）
- 每个内部节点最多有 `M-1` 个键值
- 所有叶子节点在同一层，即树高保持平衡
- 所有键值在节点中按升序排列
- 每个键值用于分隔不同子树的范围

```less
        [17 | 35]
      /     |     \
 [10]    [20|25]    [40|50] 
```

>因为 B 树的特性，在相同的数据量的情况下，它比二叉树更矮，而每经过一层树就需要一次 IO 操作，所以 B 树可用有效地减少 IO 操作次数，提高效率

****
# 2. B+ 树

>B+ 树是在 B 树的基础上演化出来的一种多路平衡查找树，是数据库索引最常用的结构。B+ 树中的非叶子节点都不存储数据，而是只作为索引（划分范围），由叶子节点存放整棵树的所有数据，所以整体的高度不会很高，所以查询速度很快。而叶子节点之间构成一个从小到大有序的链表互相指向相邻的叶子节点，也就是叶子节点之间形成了有序的双向链表

![](images/B+%20树索引/file-20250522195021.png)

插入与删除：

>B+ 树做了大量冗余节点，父节点的所有元素都会在子节点中出现，当删除一个节点时，可以直接从叶子节点中删除，只需要调整叶子节点，平衡操作效率更高，插入操作类似，最多只涉及树的一条分支路径

****
# 3. MySQL 索引为什么使用 B+ 树结构？

## 普通 SQL 的全表扫描过程

![](images/B+%20树索引/file-20250522203937.png)

>在 MySQL 的 InnoDB 存储引擎中，数据是按页为单位进行管理和读写的，每页大小默认为 16KB，可以存放多条记录（具体数量取决于每条记录的大小）

当执行 `select * from users where name = '熊猫'` 时，如果没有使用索引（全表扫描），InnoDB 会从磁盘读取一个或多个页到内存中进行判断。而 MySQL 会使用局部性原理，所以它并不会一次只读取一条记录，而是一次性将一整个数据页读入内存，即使“熊猫”是第五条记录，只要它和前四条记录位于同一个数据页中，也只需一次 IO 操作即可获取到它所在的记录块

然后会继续进行下一次 IO 操作读取更多页，直到整张表扫描完毕为止，所有符合条件的记录会被临时保存在内存中的结果集中，最后一并返回给客户端（因为表中的字段没有建立唯一索引或唯一约束，因此 MySQL 不确定是否还有其他同名的数据，所以需要将整个表全部扫描一遍，才能得到最终结论）

>根据以上结果可以看出，当表的数据非常庞大时，一次全表扫描可能会触发非常多次的 IO 操作，这会导致开销十分大，为了避免全表扫描，就引入了索引机制

****
## 3.2 索引为什么不选二叉树？

>二叉树搜索是基于二分搜索法实现的一种数据结构，在理想情况下是平衡的，高度为 `log₂N`（N 是节点数），但在最坏情况下树的结构可能成为一条线，此时退化成单链表，高度变为 `N`，搜索效率变为 O(N)，会让 IO 操作变多，并且此时和全表扫描没有什么差异

****
## 3.3 索引为什么不用红黑树？

>红黑树是一种自平衡的二叉树，它不会退化成单链表的情况，但是它的节点只能存储一个数据，并且自平衡的特性会导致节点中存储的数据不连续，这样就无法利用局部性原理，随着数据的增多，IO 次数并不会得到明显的降低

****
## 3.4 索引为什么不用 B 树？

>在 B 树中，每个节点会存储关键字和数据，但数据通常比索引 key 更大，这就导致单个节点能容纳的关键字数量变少，而这就会导致树变高

假设一个磁盘页 16KB，一个 key 8 字节，一个数据行 200 字节：

>如果节点只存 key，能容纳约 2000 个 key，如果每个 key 携带一条数据，只能容纳 70 多个键值对，树的高度差别会非常明显，而数据又分布在所有节点中，数据结构零散，不利于使用局部性原理与大范围查询，所以仍然不能有效降低 IO 次数

****
## 3.5 索引为什么不用数组？

>数组的优点就是快速查找，看似适合作为索引，但是它的插入与删除的成本太高了，并且 MySQL 经常使用范围查询，所以不适合

****
## 3.6 索引为什么使用 B+ 树？

1、范围查询优化

>B+ 树叶子节点形成链表，只需定位首节点即可顺序遍历获取范围数据（较少次数 IO 定位 + 顺序读取），完美解决 B 树范围查询需要回溯到父节点的问题

2、更矮胖的树结构

>非叶子节点仅存储键值和子节点指针（不包含实际数据），因此单个页就能容纳更多索引项；对于 聚簇索引（主键索引）：叶子节点叶子节点存储的是整行数据，对于辅助索引（非聚簇索引）叶子节点存储的是索引列值 + 主键值，通过主键值再回表查询原始数据

****
## 3.7 B+ 树为何会存在叶节点呢？

>一次 IO 读取的数据量是有限制的，如果将所有的数据全放入到一个节点中存储，那一次 IO 只能读取节点的一部分数据，将整个节点读完本质上就和之前走一次全表没区别了

因为 B+ 树的节点有大小限制，如果将所有数据存储在叶节点上就会导致存储的索引键很少，就和 B 树一样，当使用叶节点做导航，叶子节点存储真实数据，就可用进行快速的访问，而冗余的索引键存在于叶节点和父节点中，就是为了在保持树高尽可能低的前提下，同时能高效访问数据

****
# 4. 聚簇索引与非聚簇索引的查找过程

## 4.1 聚簇索引

```sql
select * from user where id = 12;
```

> InnoDB 会根据 B+ 树结构，从根节点开始查找，先加载根节点所在的磁盘页到内存，然后通过二分查找方式在节点中找到匹配的键值区间，根据对应指针跳转到下一个子节点，这个过程重复进行，直到查找到叶子节点。最后找到键为 `id = 12` 的那条记录，即可读取整行数据，完成查询

为什么聚簇索引效率高：

- B+ 树的叶子节点在聚簇索引中不仅仅是索引，它存的是整行数据本身，无需回表
- B+ 树的结构较“矮胖”，一般高度只有 3~4 层，即便数据量达千万级，查找路径也只需 3～4 次 IO
- 每次磁盘 IO 读取的是一个完整的数据页（例如 16 KB），受益于局部性原理，可能提前把后续要用到的数据也读到内存中，进一步减少 IO

****
## 4.2 非聚簇索引

相较于聚簇索引而言，非聚簇索引前面的步骤都是相同的，仅是最后一步有些许不同。非聚簇索引经过一系列查询步骤后，最终会取到一个聚簇索引的字段值，然后再做一次回表查询，也就是再去聚簇索引中查一次才能取到数据。










