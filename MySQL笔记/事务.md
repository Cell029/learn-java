
# 1. 什么是数据库事务？

事务（Transaction）是数据库中最小的工作单元，它表示一组必须作为一个整体执行的操作集合（要么全部执行成功，要么全部不执行）

>一个业务的完成可能需要多条 DML 语句（INSERT、UPDATE、DELETE）共同配合才能完成，例如转账业务，需要执行两条 DML 语句，先更新张三账户的余额，再更新李四账户的余额，为了保证转账业务不出现问题，就必须保证要么同时成功，要么同时失败，怎么保证同时成功或者同时失败呢？就需要使用事务机制。

****
# 2. 事务的四大特性

1、原子性（Atomicity）

>事务中的操作要么全部执行成功，要么全部不执行。事务中的所有 SQL 语句是一个整体，不允许只执行一部分，如果其中任何一条语句失败，事务将全部回滚，回到事务开始前的状态

例如：张三转账给李四的事务中，扣款成功但加款失败，整个事务回滚，张三的钱也恢复

2、一致性（Consistency）

>执行事务前后，数据库的数据应始终一致

例如：如果张三和李四总共有 5000 元，无论怎么转账，事务执行后，两人总额仍应为 5000

3、隔离性（Isolation）

>多个并发事务之间互不影响，彼此隔离，数据库通过设置事务隔离级别来控制隔离性的强度（例如：读未提交、读已提交、可重复读、串行化）

例如：A 正在修改账户余额，B 同时查询账户信息，如果没有隔离机制，B 可能读到 A 尚未提交的中间数据

4、持久性（Durability）

>一旦事务提交，对数据的更改就会永久保存，即使系统崩溃也不会丢失，数据库通过日志机制（如 redo log）来保证数据的持久化

例如：用户转账后显示“交易成功”，哪怕服务器突然断电，重启后数据仍然是已转账状态

****
# 3. MySQL 中的事务控制语句

如果 DML 语句执行成功就 COMMIT，否则 ROLLBACK：

```sql
START TRANSACTION;       -- 或 BEGIN;
-- 执行多个 DML 语句
COMMIT;                  -- 提交事务，数据永久生效
-- 或
ROLLBACK;                -- 回滚事务，撤销全部修改
```

需要注意的是：

>事务只作用于 INSERT、UPDATE、DELETE，不适用于 `CREATE`, `DROP`, `ALTER`（这些属于 DDL，执行即生效，不能回滚）

### 自动提交和手动提交

1、自动提交

MySQL 默认开启自动提交模式，每条语句执行后立即生效（自动提交事务）：

```sql
SELECT @@autocommit;  -- 查看是否开启自动提交
SET autocommit = 0;   -- 手动关闭自动提交
```

![](images/事务/file-20250520170241.png)

2、手动提交

当业务逻辑的完整性要求较高时推荐使用手动提交

```sql
SET autocommit = 0;        -- 关闭自动提交
START TRANSACTION;         -- 开始事务
-- 执行操作
COMMIT 或 ROLLBACK;        -- 提交或回滚
SET autocommit = 1;        -- 恢复自动提交
```

****
# 4. 事务的隔离级别

| 隔离级别                       | 脏读  | 不可重复读 | 幻读  | 说明                                         |
| -------------------------- | --- | ----- | --- | ------------------------------------------ |
| **READ UNCOMMITTED**（读未提交） | 可能  | 可能    | 可能  | 最低级别，事务可以读取其他未提交事务的数据，性能高但不安全              |
| **READ COMMITTED**（读已提交）   | 禁止  | 可能    | 可能  | 只能读取其他事务已提交的数据，防止脏读，大多数数据库默认级别（如 Oracle）。  |
| **REPEATABLE READ**（可重复读）  | 禁止  | 禁止    | 可能  | 同一个事务内多次读取的结果一致，防止不可重复读，MySQL InnoDB 的默认级别 |
| **SERIALIZABLE**（可串行化）     | 禁止  | 禁止    | 禁止  | 最严格，所有事务串行执行，防止所有并发问题，但效率最低                |

## 4.1 查看与设置隔离级别

1、查看

```sql
SELECT @@transaction_isolation;
-- 或者
SELECT @@global.transaction_isolation;
```

![](images/事务/file-20250520171527.png)

2、设置

作用范围的设置：

```sql
-- 设置当前会话隔离级别（只影响当前连接）
SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;

-- 设置全局隔离级别（重启后仍然有效）
SET GLOBAL TRANSACTION ISOLATION LEVEL READ COMMITTED;
```

四种级别的设置：

```sql
-- 读未提交
SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
SET GLOBAL TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

-- 读已提交
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;
SET GLOBAL TRANSACTION ISOLATION LEVEL READ COMMITTED;

-- 可重复读
SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;
SET GLOBAL TRANSACTION ISOLATION LEVEL REPEATABLE READ;

-- 串行化
SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;
SET GLOBAL TRANSACTION ISOLATION LEVEL SERIALIZABLE;
```

****
## 4.2 读未提交

将当前终端（A 终端）的事务隔离级别设置为读未提交 read uncommitted：

```sql
begin;  
select * from account where id = 2;
```

在终端 A 开启事务并查询熊二的账户余额

![](images/事务/file-20250520173609.png)

```sql
begin;
update account set balance = balance + 50 where id = 2;
```

在中端 B 开启事务并向熊二的账户余额添加 50 元 

![](images/事务/file-20250520173829.png)

>终端 A 事务读取到了终端 B 事务还未提交的数据，这个问题就是脏读，而终端 A 事务两次读取的数据不一致，这个问题就是不可重复读

****

然后 B 终端回滚数据，而 A 终端的事务对熊二账户余额进行减 50 元：

```sql
B：
rollback;
select * from account where id = 2;
```

![](images/事务/file-20250520174557.png)

```sql
A:
update account set balance = balance - 50 where id = 2;  
commit;  
select * from account where id = 2;
```

>此时可以看到熊二的账户余额变成了 350，并不是 400

![](images/事务/file-20250520174724.png)

整体时间线：

| 时间线 | 终端 A 事务                                                          | 终端 B 事务                                                   |
| --- | ---------------------------------------------------------------- | --------------------------------------------------------- |
| 1   | `begin;`                                                         |                                                           |
| 2   | `select * from account where id = 2; ` <br>读到熊二的账户余额为 400 元      |                                                           |
| 3   |                                                                  | `begin;`                                                  |
| 4   |                                                                  | `update account set balance = balance + 50 where id = 2;` |
| 5   | `select * from account where id = 2; ` <br>读到熊二的账户余额为 450 元 （脏读） |                                                           |
| 6   |                                                                  | `rollback;`                                               |
| 7   |                                                                  | `select * from account where id = 2;`<br>读到熊二的账户余额为 400 元 |
| 8   | `update account set balance = balance - 50 where id = 2;`        |                                                           |
| 9   | `commit;`                                                        |                                                           |
| 10  | `select * from account where id = 2;`<br>读到熊二的账户余额为 350 元 (不受影响) |                                                           |

>在应用程序中，如果一个事务读到脏数据，并作为其他业务逻辑的依据或者进行其他处理，但其并不知道其他会话回滚了事务，那么后续的整个逻辑处理都可能存在问题

****
## 4.3 读已提交

开启两个终端分别为 A 和 B，并将当前终端的事务隔离级别设置为读已提交 read committed：

```sql
set session transaction isolation level read committed;  
select @@session.transaction_isolation;
```

![](images/事务/file-20250520175443.png)

在终端 A 开启事务并查询光头强的账户余额：

```sql

```


