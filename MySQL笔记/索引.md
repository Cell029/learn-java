
>索引是 MySQL 中用于提高查询效率的关键机制，其本质是数据库表中一列或多列值的有序数据结构，通过索引可以快速定位数据，而不用每次都全表扫描

# 1. 概述

## 1.1 索引的创建

1、 使用 CREATE 语句

```sql
-- 普通索引
CREATE INDEX 索引名 ON 表名 (字段名(length) [ASC|DESC]);

-- 唯一索引
CREATE UNIQUE INDEX 索引名 ON 表名(字段名);

-- 组合索引
CREATE INDEX 索引名 ON 表名(字段1, 字段2);
```

2、使用 ALTER 语句

```sql
-- 普通索引
ALTER TABLE 表名 ADD INDEX 索引名(字段名(length) [ASC|DESC]);

-- 唯一索引
ALTER TABLE 表名 ADD UNIQUE INDEX 索引名(字段名);

-- 组合索引
ALTER TABLE 表名 ADD INDEX 索引名(字段1,字段2);
```

3、建表时 DDL 语句中创建

```sql
CREATE TABLE 表名(  
  字段1 INT(8) NOT NULL,   
  字段2 ....,
  .....,
  INDEX 索引名 (字段名(length))  
);
```

****
## 1.2 查询、删除、指定索引

1、查询索引

```sql
SHOW INDEX FROM 表名;
```

![](images/索引/file-20250522173148.png)

- `Non_unique`：是否唯一索引（0 表示唯一，1 表示非唯一）
- `Key_name`：索引名称（如 PRIMARY）
- `Seq_in_index`：索引中字段的顺序（1 表示第一个字段）
- `Column_name`：被索引的列名
- `Collation`：列在索引中的排序方式：`A` 表示升序，`D` 表示降序，`NULL` 表示未排序
- `Cardinality`：基数，表示索引中唯一值的估计数量（影响查询优化器选择）
- `Sub_part`：索引的前缀长度(如果是部分索引)，`NULL` 表示整列被索引
- `Packed`：键是否被压缩，`NULL` 表示未压缩
- `Null`：列是否允许包含 NULL 值
- `Index_type`：索引类型，如 BTREE、FULLTEXT

2、删除索引

```sql
ALTER TABLE 表名 DROP INDEX 索引名;
```

>需要注意的是：不能通过 `DROP INDEX` 删除主键索引，需要用 `DROP PRIMARY KEY` 

3、指定索引

MySQL 默认由查询优化器选择最优索引，但可以通过以下方式手动指定使用某个索引：

```sql
-- 强制使用某个索引，哪怕优化器认为其他方式更快
SELECT * FROM 表名 FORCE INDEX (索引名) WHERE 条件;

-- 建议使用指定索引，但如果优化器认为不可行，可不使用
SELECT * FROM 表名 USE INDEX (索引名) WHERE 条件;

-- 告诉优化器不要使用某个索引
SELECT * FROM 表名 IGNORE INDEX (索引名) WHERE 条件;
```

****
## 1.3 索引的本质

>索引本质上是磁盘上的一种特殊数据结构文件，它和表一样都是物理数据的一部分，因此与表数据相同，最终创建出的索引也会在磁盘生成本地文件，不过索引文件在磁盘中的存储方式是由索引的数据结构来决定的，同时，由于索引机制最终是由存储引擎实现，因此不同存储引擎下的索引文件保存在本地的格式也并不相同

需要注意的是：

>创建索引并不是单纯的给表添加一个约束，而是基于原表的数据，重新在磁盘中创建新的本地索引文件，假设表中有一千万条数据，那创建索引时，就需要将索引字段上的一千万个值全部拷贝到本地索引文件中，同时做好排序并与表数据产生映射关系

****
# 2. 索引的分类

## 2.1 功能层次

|类型|简要说明|适用场景|
|---|---|---|
|**主键索引（PRIMARY KEY）**|表中唯一的主键，不能重复，不能为空|用于唯一标识一条记录|
|**唯一索引（UNIQUE）**|索引列的值必须唯一，但可以为 `NULL`|限制列值不能重复，如身份证号、邮箱|
|**普通索引（INDEX / KEY）**|没有限制的索引，值可重复可为空|提高普通字段查询效率|
|**组合索引（联合索引）**|多个字段组成一个索引|支持多个字段作为筛选条件的查询|
|**全文索引（FULLTEXT）**|用于文本搜索，可分词匹配|适合对大文本字段（如文章）做模糊搜索|
|**空间索引（SPATIAL）**|用于存储几何数据的字段|多用于地理信息系统（GIS）应用|

### 1. 主键索引（PRIMARY KEY）

>表中只能有一个主键索引，自动具有唯一性约束，不能为 `NULL`，在 InnoDB 中主键索引就是聚簇索引

```sql
CREATE TABLE user (
  id INT PRIMARY KEY,
  name VARCHAR(50)
);
```

****
### 2. 唯一索引（UNIQUE）

>保证列中的数据是唯一不可重复的，但允许 `NULL`（多个 NULL 也是允许的），也可以创建多个唯一索引

```sql
CREATE UNIQUE INDEX 索引名 ON 表名(字段);
```

****
### 3. 普通索引（INDEX / KEY）

>没有唯一性限制，可以重复，主要是提高 `WHERE` 、`ORDER BY` 的查询效率

```sql
CREATE INDEX 索引名 ON 表名(字段);
```

****
### 4. 组合索引

>由多个列组成的索引，常用于多条件查询，遵循最左前缀原则：只要满足索引列的最左边一部分（即满足字段 1），也能被使用

```sql
CREATE INDEX 索引名 ON 表名(字段1, 字段2);

CREATE INDEX name_age ON user(name, age);
SELECT * FROM user WHERE age = 18; -- 这种查询就用不上组合索引
```

****
### 5. 全文索引

>支持自然语言的分词搜索，适合大文本内容，但只支持 `CHAR`、`VARCHAR`、`TEXT`，仅 InnoDB（MySQL 5.6+）和 MyISAM 支持

```sql
CREATE TABLE 表名 (
  id INT PRIMARY KEY,
  content TEXT,
  FULLTEXT(content)
);
```

```sql
SELECT * FROM 表名 WHERE MATCH(字段) AGAINST('具体内容');
```

****
### 6. 空间索引

>用于几何数据类型（如 `POINT`、`LINESTRING`），只能用于 MyISAM 引擎（InnoDB 也在支持中，但受限较多）

****
## 2.2 数据结构层次

| 数据结构       | 索引类型        | 特点              |
| ---------- | ----------- | --------------- |
| **B+ 树索引** | 主键、唯一、普通、组合 | 默认结构，适合范围查找     |
| **哈希索引**   | MEMORY 引擎   | 快速定位，无法排序或做范围查找 |
| **倒排索引**   | 全文索引        | 支持关键字搜索、模糊匹配    |
| **R-Tree** | 空间索引        | 专用于二维空间坐标查找     |

1、哈希索引

>Hash 索引的底层结构是一个哈希表，它的工作方式是：对插入的索引列做一次哈希函数运算，得出一个哈希码，然后将这个值映射到哈希桶中并存储在对应桶中对应的数据地址

但哈希索引不适合做范围查找：

>因为哈希值是无序的，相近值可能 hash 结果相差极远，并且它不具有比较大小的能力，本质上是用来判断是否相等的，所以适合于精准查询

虽然 InnoDB 不支持哈希索引，但它有一个自适应哈希索引机制，会自动根据热点查询构建 Hash 索引，提高效率。这个过程由引擎自动控制，使用者不需要也无法主动创建

****
## 2.3 存储方式层次

从存储方式来看，`MySQL`的索引主要可分为两大类：

- 聚簇索引：也被称为聚集索引、簇类索引
- 非聚簇索引：也叫非聚集索引、非簇类索引、二级索引、辅助索引、次级索引

1、聚簇索引

>聚簇索引是数据与索引合在一起存储的索引结构，索引的叶子节点就是数据行本身，而在 InnoDB 存储引擎中，每个表只能有一个聚簇索引，因为数据行只能按照一种方式排序存储。

```sql
CREATE TABLE user (
  id INT PRIMARY KEY,
  name VARCHAR(100),
  age INT
);
```

>在这个表中，主键 `id` 就是聚簇索引，InnoDB 会将整行数据（id, name, age）存储在 B+ 树叶子节点中，并按 id 有序排列。查找 `id = 5` 的数据时，只需通过聚簇索引定位到叶子节点，即可直接获取整行数据

2、非聚簇索引

>非聚簇索引是指：索引结构与数据分开存储，索引的叶子节点存储的是主键值（而不是整行数据）。查找数据需要回表操作，通过非聚簇索引定位主键值，再用主键值去聚簇索引中查数据

```sql
CREATE INDEX idx_name ON user(name);
```

>这个就是非聚簇索引，`idx_name` 索引的叶子节点是 (name, id)，查找相应的 `name` 时先在`idx_name` 中找到匹配的主键 `id`，再根据 `id` 去聚簇索引中取完整数据（默认聚簇索引是主键）

****








